<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="会熟练拼写Python、Java、React"><title>JS-创建对象 | 一点知识</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JS-创建对象</h1><a id="logo" href="/.">一点知识</a><p class="description">xukf</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/diary/"><i class="fa fa-book"> 日志</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JS-创建对象</h1><div class="post-meta">Dec 17, 2018<span> | </span><span class="category"><a href="/categories/前端/">前端</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2,051</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span><script type="text/javascript" src="/js/love.js"></script></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#创建对象"><span class="toc-number">1.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂模式"><span class="toc-number">1.1.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-number">1.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-number">1.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数模式"><span class="toc-number">1.2.</span> <span class="toc-text">构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型模式"><span class="toc-number">1.3.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象字面量重写原型对象"><span class="toc-number">1.3.1.</span> <span class="toc-text">对象字面量重写原型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型的动态性"><span class="toc-number">1.3.2.</span> <span class="toc-text">原型的动态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优点-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点-2"><span class="toc-number">1.3.4.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合使用构造函数模式与原型模式"><span class="toc-number">1.4.</span> <span class="toc-text">组合使用构造函数模式与原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态原型模式"><span class="toc-number">1.5.</span> <span class="toc-text">动态原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寄生构造函数模式"><span class="toc-number">1.6.</span> <span class="toc-text">寄生构造函数模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#稳妥构造函数模式"><span class="toc-number">1.7.</span> <span class="toc-text">稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#延伸"><span class="toc-number">2.</span> <span class="toc-text">延伸</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于原型模式中的原型对象"><span class="toc-number">2.1.</span> <span class="toc-text">关于原型模式中的原型对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原型对象"><span class="toc-number">2.1.1.</span> <span class="toc-text">原型对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对象属性搜索方式"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">对象属性搜索方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型对象与实例对象"><span class="toc-number">2.1.2.</span> <span class="toc-text">原型对象与实例对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#各创建模式在Chrome浏览器中的表现"><span class="toc-number">3.</span> <span class="toc-text">各创建模式在Chrome浏览器中的表现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文章"><span class="toc-number">3.0.1.</span> <span class="toc-text">参考文章</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>对js（ES5）中创建对象的主要三种方式：工厂模式、构造函数模式、原型模式进行比较分析，<br>并了解寄生构造函数模式与稳妥构造函数模式</p>
<a id="more"></a>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>使用<code>new Object()</code>或者对象字面量都可以创建对象，但是这样创建的对象过于简单，不易于对象的属性与方法的扩展与继承。<br>下面讲的对象可以与<code>javaee</code>中的<code>bean</code>做类比。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>对，首先可能想到的是使用设计模式中的<strong>工厂模式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPizza</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.type = type;</span><br><span class="line">  o.bake = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Start~'</span>);</span><br><span class="line">    alert(<span class="keyword">this</span>.type);</span><br><span class="line">    alert(<span class="string">'End~'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cheesePizza = createPizza(<span class="string">'cheese'</span>);</span><br><span class="line"><span class="keyword">var</span> veggiePizza = createPizza(<span class="string">'veggie'</span>);</span><br><span class="line">cheesePizza.bake();</span><br></pre></td></tr></table></figure></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>工厂模式解决了创建多个类似对象的问题  </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>对象无法识别，即创建出来的对象无法通过<code>instanceof</code>等分析出属于哪种类型</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>用构造函数可用来创建特定类型的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数首字母遵循OO语言惯例进行大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pizza</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">  <span class="keyword">this</span>.bake = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Start~'</span>);</span><br><span class="line">    alert(<span class="keyword">this</span>.type);</span><br><span class="line">    alert(<span class="string">'End~'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cheesePizza = <span class="keyword">new</span> Pizza(<span class="string">'cheese'</span>);</span><br><span class="line"><span class="keyword">var</span> veggiePizza = <span class="keyword">new</span> Pizza(<span class="string">'veggie'</span>);</span><br><span class="line">cheesePizza.bake();</span><br></pre></td></tr></table></figure></p>
<p>与工厂模式相比：</p>
<ol>
<li>没有在方法中显示创造对象（o）；</li>
<li>直接将属性与方法赋值给this；</li>
<li>没有<code>return</code>语句</li>
</ol>
<p>在用<code>new</code>的时候，会经历一下4步：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（此时this指向新对象）</li>
<li>执行构造函数代码（为对象添加属性）</li>
<li>返回新对象</li>
</ol>
<blockquote>
<p>如果不使用new，将构造函数当做函数使用，则this指向Global对象（在浏览器中为window对象），当然，可以使用call方法来指定作用域，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Pizza.call(o, <span class="string">'salty'</span>);</span><br><span class="line">o.bake();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>使用<strong>构造函数方法</strong>，每个实例对象都有一个<code>constructor</code>构造函数属性，该属性指向Pizza（使用对象字面量、工厂模式方法创建的对象该属性指向Object）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheesePizza.constructor == Pizza</span><br></pre></td></tr></table></figure></p>
<p>检查某个对象属于哪种类型，一般使用<code>instanceof</code>，cheesePizza同时属于<code>Pizza</code>与<code>Object</code>（之所以属于Object，是因为所有对象均继承于Object）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cheesePizza <span class="keyword">instanceof</span> Pizza;</span><br><span class="line">cheesePizza <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>与工厂模式相比，构造函数模式能够识别出对象类型<br>与下面的原型模式相比，能够实现对象属性的互相独立，在引用类型属性上很有用</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>每个实例对象的方法都是独立的，导致方法不能够共享</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数（不是实例对象）都有一个<code>prototype</code>属性，该属性是一个指针，指向一个对象，对象的用途是包含所有实例共享的属性和方法。prototype通过调用构造函数创建的那个对象实例的<strong>原型对象</strong>。使用原型对象的好处是可以让所有实例对象共享属性与方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pizza</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pizza.prototype.type = <span class="string">'original'</span></span><br><span class="line">Pizza.prototype.bake = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Start~'</span>);</span><br><span class="line">  alert(<span class="keyword">this</span>.type);</span><br><span class="line">  alert(<span class="string">'End~'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cheesePizza = <span class="keyword">new</span> Pizza();</span><br><span class="line">cheesePizza.type = <span class="string">'cheese'</span>;</span><br><span class="line"><span class="keyword">var</span> veggiePizza = <span class="keyword">new</span> Pizza();</span><br><span class="line">veggiePizza.type = <span class="string">'veggie'</span>;</span><br><span class="line"></span><br><span class="line">cheesePizza.bake();</span><br><span class="line">veggiePizza.bake();</span><br></pre></td></tr></table></figure></p>
<p>各个对象共享属性与方法，同时每个对象都可以建立自己的属性，并<strong>屏蔽</strong>掉原型对象的同名属性，因为共享属性与方法，所以以下等式成立<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheesePizza.bake == veggiePizza.bake</span><br></pre></td></tr></table></figure></p>
<h3 id="对象字面量重写原型对象"><a href="#对象字面量重写原型对象" class="headerlink" title="对象字面量重写原型对象"></a>对象字面量重写原型对象</h3><p>也可以通过对象字面量来重写整个原型对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pizza.prototype = &#123;</span><br><span class="line">  type: <span class="string">'original'</span>,</span><br><span class="line">  bake: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Start~'</span>);</span><br><span class="line">    alert(<span class="keyword">this</span>.type);</span><br><span class="line">    alert(<span class="string">'End~'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样完全重写，原型对象上的<code>constructor</code>属性不再指向<code>Pizza</code>函数（全新的constructor指向Object），不过不影响通过<code>instanceof</code>来识别对象类型。如果<code>constructor</code>特别重要的话，可以显式将它置为适当的值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pizza.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Pizza,</span><br><span class="line">  type: 'original',</span><br><span class="line">  bake: function() &#123;</span><br><span class="line">    alert(<span class="string">'Start~'</span>);</span><br><span class="line">    alert(<span class="keyword">this</span>.type);</span><br><span class="line">    alert(<span class="string">'End~'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过这种方式会将<code>constructor</code>的属性特征变为可枚举，而默认情况下它是不可枚举的，如果想不可枚举，可以使用<code>Object.defineProperty()</code>方法。</p>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>对原型对象的修改会体现在实例对象上，即使实例对象先被创建。但是通过对象字面量重写的原型对象则没有该动态性</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>定义在原型对象上的属性，能够保证在各实例对象上的共享</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>对于引用类型的属性，各实例的共享会导致额外的问题。</p>
<h2 id="组合使用构造函数模式与原型模式"><a href="#组合使用构造函数模式与原型模式" class="headerlink" title="组合使用构造函数模式与原型模式"></a>组合使用构造函数模式与原型模式</h2><p>整合构造函数模式与原型模式，构造函数模式用于定义实例属性，原型模式用于定义方法和共享属性。</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><h2 id="关于原型模式中的原型对象"><a href="#关于原型模式中的原型对象" class="headerlink" title="关于原型模式中的原型对象"></a>关于原型模式中的原型对象</h2><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>每个函数都会被一组特定的规则创建一个<code>prototype</code>属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，是一个指向prototype所在函数的指针。以Pizza为例<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pizza<span class="selector-class">.prototype</span><span class="selector-class">.constructor</span> == Pizza</span><br></pre></td></tr></table></figure></p>
<p>每当使用构造函数创建一个新实例时，该实例的内部将包含一个指针[[Prototype]]，指向原型对象，在chrome等浏览器中，该属性表现形式为<code>__proto__</code>（可以参见文章末尾），在chrome等浏览器中，以下等式成立：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheesePizza.__proto__.constructor == Pizza</span><br></pre></td></tr></table></figure></p>
<p>构造函数、原型对象、实例对象的关联关系为：</p>
<ul>
<li>构造函数中有<code>prototype</code>属性指向原型对象</li>
<li>原型对象中有<code>constructor</code>属性指向<code>prototype</code>所在的构造函数</li>
<li>实例对象中有[[Prototype]]属性指向原型对象，但是实例对象与构造函数没有直接关系  </li>
</ul>
<h4 id="对象属性搜索方式"><a href="#对象属性搜索方式" class="headerlink" title="对象属性搜索方式"></a>对象属性搜索方式</h4><p>搜索顺序为：</p>
<ol>
<li>先判断该属性是否存在于对象实例本身</li>
<li>在1不满足的条件下搜索原型对象</li>
</ol>
<h3 id="原型对象与实例对象"><a href="#原型对象与实例对象" class="headerlink" title="原型对象与实例对象"></a>原型对象与实例对象</h3><p>这部分要重点注意，在配置ESLint检查循环遍历代码的时候，会建议使用如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(foo, key)) &#123;</span><br><span class="line">        doSomething(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>for-in</code>循环会返回所有可通过对象访问的、可枚举的属性，通过<code>hasOwnProperty()</code>方法可以区分某属性是存在于原型对象还是实例对象上，从而保证不期望的原型对象属性被遍历。若想遍历只在实例对象上的属性，建议使用<code>Object.keys()</code>代替<code>for-in</code>循环，返回结果为实例对象属性数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(cheesePizza);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果想要获得实例对象所有属性，可以使用<code>Object.getOwnPropertyNames()</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(cheesePizza)</span><br><span class="line">&gt; [<span class="string">"type"</span>]</span><br><span class="line">  <span class="number">0</span>: <span class="string">"type"</span></span><br><span class="line">  length: <span class="number">1</span></span><br><span class="line">  __proto__: <span class="built_in">Array</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="各创建模式在Chrome浏览器中的表现"><a href="#各创建模式在Chrome浏览器中的表现" class="headerlink" title="各创建模式在Chrome浏览器中的表现"></a>各创建模式在Chrome浏览器中的表现</h1><p>可以通过Chrome浏览器观察使用工厂模式创建的cheesePizza对象属性为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cheesePizza</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"cheese"</span>, <span class="attr">bake</span>: ƒ&#125;</span><br><span class="line">  bake: ƒ ()</span><br><span class="line">  type: <span class="string">"cheese"</span></span><br><span class="line">  __proto__:</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ Object()</span><br><span class="line">    hasOwnProperty: ƒ hasOwnProperty()</span><br><span class="line">    isPrototypeOf: ƒ isPrototypeOf()</span><br><span class="line">    propertyIsEnumerable: ƒ propertyIsEnumerable()</span><br><span class="line">    toLocaleString: ƒ toLocaleString()</span><br><span class="line">    toString: ƒ toString()</span><br><span class="line">    valueOf: ƒ valueOf()</span><br><span class="line">    __defineGetter__: ƒ __defineGetter__()</span><br><span class="line">    __defineSetter__: ƒ __defineSetter__()</span><br><span class="line">    __lookupGetter__: ƒ __lookupGetter__()</span><br><span class="line">    __lookupSetter__: ƒ __lookupSetter__()</span><br><span class="line">    get __proto__: ƒ __proto__()</span><br><span class="line">    set __proto__: ƒ __proto__()</span><br></pre></td></tr></table></figure></p>
<p>使用构造函数模式创建cheesePizza对象属性为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cheesePizza</span><br><span class="line">Pizza &#123;<span class="attr">type</span>: <span class="string">"cheese"</span>, <span class="attr">bake</span>: ƒ&#125;</span><br><span class="line">  bake: ƒ ()</span><br><span class="line">  type: <span class="string">"cheese"</span></span><br><span class="line">  __proto__:</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ Pizza(type)</span><br><span class="line">    __proto__:</span><br><span class="line">      <span class="keyword">constructor</span>: ƒ Object()</span><br><span class="line">      hasOwnProperty: ƒ hasOwnProperty()</span><br><span class="line">      isPrototypeOf: ƒ isPrototypeOf()</span><br><span class="line">      propertyIsEnumerable: ƒ propertyIsEnumerable()</span><br><span class="line">      toLocaleString: ƒ toLocaleString()</span><br><span class="line">      toString: ƒ toString()</span><br><span class="line">      valueOf: ƒ valueOf()</span><br><span class="line">      __defineGetter__: ƒ __defineGetter__()</span><br><span class="line">      __defineSetter__: ƒ __defineSetter__()</span><br><span class="line">      __lookupGetter__: ƒ __lookupGetter__()</span><br><span class="line">      __lookupSetter__: ƒ __lookupSetter__()</span><br><span class="line">      get __proto__: ƒ __proto__()</span><br><span class="line">      set __proto__: ƒ __proto__()</span><br></pre></td></tr></table></figure></p>
<p>使用原型模式创建cheesePizza对象属性为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cheesePizza</span><br><span class="line">Pizza &#123;<span class="attr">type</span>: <span class="string">"cheese"</span>&#125;</span><br><span class="line">  type: <span class="string">"cheese"</span></span><br><span class="line">  __proto__:</span><br><span class="line">    bake: ƒ ()</span><br><span class="line">    type: <span class="string">"original"</span></span><br><span class="line">    <span class="keyword">constructor</span>: ƒ Pizza()</span><br><span class="line">    __proto__:</span><br><span class="line">      <span class="keyword">constructor</span>: ƒ Object()</span><br><span class="line">      hasOwnProperty: ƒ hasOwnProperty()</span><br><span class="line">      isPrototypeOf: ƒ isPrototypeOf()</span><br><span class="line">      propertyIsEnumerable: ƒ propertyIsEnumerable()</span><br><span class="line">      toLocaleString: ƒ toLocaleString()</span><br><span class="line">      toString: ƒ toString()</span><br><span class="line">      valueOf: ƒ valueOf()</span><br><span class="line">      __defineGetter__: ƒ __defineGetter__()</span><br><span class="line">      __defineSetter__: ƒ __defineSetter__()</span><br><span class="line">      __lookupGetter__: ƒ __lookupGetter__()</span><br><span class="line">      __lookupSetter__: ƒ __lookupSetter__()</span><br><span class="line">      get __proto__: ƒ __proto__()</span><br><span class="line">      set __proto__: ƒ __proto__()</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://eslint.bootcss.com/docs/rules/guard-for-in/" target="_blank" rel="noopener">ESLint 需要约束 for-in (guard-for-in)</a>  </p>
</div><div class="tags"><a href="/tags/js/">js</a></div><div class="license-space"></div><div class="license-content"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a><span>本作品采用</span><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">'知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议'</a><span>进行许可。</span></div><div class="license-space"></div><div class="post-nav"><a class="pre" href="/2018/12/29/JS-参数对象新增方法/">JS-参数对象新增方法</a><a class="next" href="/2018/12/02/JS-bind方法参数分析/">JS-bind方法参数分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/FreshMan/">FreshMan</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Whisper/">Whisper</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后台/">后台</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OGG/" style="font-size: 10px;">OGG</a> <a href="/tags/Docker/" style="font-size: 13.25px;">Docker</a> <a href="/tags/Echarts/" style="font-size: 16.5px;">Echarts</a> <a href="/tags/js/" style="font-size: 23px;">js</a> <a href="/tags/ESLint/" style="font-size: 13.25px;">ESLint</a> <a href="/tags/Hexo/" style="font-size: 19.75px;">Hexo</a> <a href="/tags/GitHub/" style="font-size: 16.5px;">GitHub</a> <a href="/tags/Java/" style="font-size: 13.25px;">Java</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/Linux/" style="font-size: 13.25px;">Linux</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Oracle/" style="font-size: 16.5px;">Oracle</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/React/" style="font-size: 16.5px;">React</a> <a href="/tags/Python/" style="font-size: 16.5px;">Python</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/svn/" style="font-size: 13.25px;">svn</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/设计/" style="font-size: 13.25px;">设计</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/29/JS-参数对象新增方法/">JS-参数对象新增方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/JS-创建对象/">JS-创建对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/02/JS-bind方法参数分析/">JS-bind方法参数分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/OGG+Kafka-集群重启记/">OGG+Kafka-集群重启记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/10/Docker-入门基础使用/">Docker-入门基础使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/JS-var、let、const/">JS-var、let、const</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/ESLint-安装、airbnb配置与sublimeText3插件/">ESLint-安装、airbnb配置与sublimeText3插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/16/阿里云使用记-ECS/">阿里云使用记-ECS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/10/JDK源码阅读记-Object/">JDK源码阅读记-Object</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/杂-文件内容按字段聚组统计/">杂-文件内容按字段聚组统计</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://strcpy.me/" title="strcpy" target="_blank">strcpy</a><ul></ul><a href="https://www.haomwei.com/" title="tufu9441" target="_blank">tufu9441</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">一点知识.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '24bfbdc1d2098a8d5cb427714572bbd5';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>