<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>React学习笔记-React是什么</title>
      <link href="/2018/04/05/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-React%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/04/05/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-React%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>这一章主要思考了选择React进行项目现有功能重构的原因，<strong>自己</strong>jQuery项目中遇到的使自己感到处理很复杂的问题，如果用react会不会简单；jQuery与react的区别是什么？JSX？虚拟DOM？生命周期？ES6？<br><a id="more"></a></p><h2 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h2><p>React是使用JSX语法扩展方式，通过虚拟DOM（Virtual DOM）进行渲染的js库。其他具体说明可以看<a href="https://reactjs.org/blog/2013/06/05/why-react.html" target="_blank" rel="noopener">Why did we build React?</a></p><h2 id="Why-not-jQuery"><a href="#Why-not-jQuery" class="headerlink" title="Why not jQuery"></a>Why not jQuery</h2><p>这是在思考是否选择其他框架时一直在想的问题，即使现在选择了React，也依然在反思这个问题。</p><h3 id="jQuery工作方式"><a href="#jQuery工作方式" class="headerlink" title="jQuery工作方式"></a>jQuery工作方式</h3><p>先从jQuery工作方式入手思考。常用的jQuery进行前台渲染的流程主要是：</p><ol><li><p>产生一个HTML</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">role</span>=<span class="string">'presentation'</span> <span class="attr">class</span>=<span class="string">'fs-article-bar active'</span> <span class="attr">id</span>=<span class="string">"hostLiOverview"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'#'</span> <span class="attr">id</span>=<span class="string">"hostOverview"</span> <span class="attr">role</span>=<span class="string">'button'</span>&gt;</span>概览<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>绑定事件处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hostOverviewShow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'#hostOverview'</span>).unbind(<span class="string">'click'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>($(<span class="string">'#hostLiOverview'</span>).hasClass(<span class="string">'disabled'</span>))&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">'li[id*="hostLi"]'</span>).removeClass(<span class="string">"disabled"</span>);</span><br><span class="line">    $(<span class="string">'li[id="hostLiOverview"]'</span>).addClass(<span class="string">"disabled"</span>);</span><br><span class="line">    $(<span class="string">'#hostInfoShow'</span>).empty();</span><br><span class="line">    queryHostInfo();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可见jQuery的工作方式为：通过CSS规则找到对应id（或者class等）的DOM元素，将事件绑定到该元素上，读取元素内容或根据业务逻辑，对相应DOM元素进行修改。</p><h3 id="不足呢？"><a href="#不足呢？" class="headerlink" title="不足呢？"></a>不足呢？</h3><p>审视一下项目现有的jQuery代码，以上面代码为例，由于使用jQuery需要直接操作DOM元素，当<code>#hostOverview</code>元素点击时，需要对<code>li[id*=&quot;hostLi&quot;]</code>、<code>li[id=&quot;hostLiOverview&quot;]</code>、<code>#hostInfoShow</code>这三个DOM元素进行修改。如果关联的元素再增加，需要再修改<code>hostOverviewShow</code>方法。<br>通过这种事件处理与DOM修改的方式进行界面渲染，会导致程序结构变得复杂。也许可以通过重构来审视代码，进行结构调优，但对于尚未开发完的项目，必须想出良好的代码结构，在增加新功能的时候还需要特别注意是否影响代码的重构。保持良好的结构，很艰难……</p><h2 id="React程序流程"><a href="#React程序流程" class="headerlink" title="React程序流程"></a>React程序流程</h2><p>React对于事件处理到DOM修改的流程为：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[事件<span class="number">1</span>,事件<span class="number">2</span>,...,事件<span class="function"><span class="title">n</span>] -&gt;</span> <span class="function"><span class="title">render</span> -&gt;</span> V<span class="function"><span class="title">irtual</span> DOM -&gt;</span> DOM</span><br></pre></td></tr></table></figure></p><p>不需要开发者关注某一事件触发后具体修改哪些DOM，修改会由React的<code>render</code>过程来分析比对虚拟DOM并修改真实DOM。</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX是JavaScript的语法扩展。一个明显的特点是可以直接使用HTML的元素，当然，并不局限于HTML元素，也可以是任何一个React的组件。</p><h3 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h3><p>一个简单的JSX如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WelcomeHostMonitor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;<span class="type">Hello</span> ~&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="type">WelcomeHostMonitor</span></span><br></pre></td></tr></table></figure></p><p>在JSX中，可以直接使用<code>onClick</code>的方式给一个元素绑定事件处理函数，例如：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">topBarSelect(opType)&#123;</span><br><span class="line">  console.log(<span class="string">"Now opType is:"</span>+opType);</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello ~&lt;/h1&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> onClick=&#123;<span class="keyword">this</span>.topBarSelect.bind(<span class="keyword">this</span>, <span class="string">"HostProvFile"</span>)&#125;&gt;文件监控&lt;/a&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对元素增加onClick是否合理"><a href="#对元素增加onClick是否合理" class="headerlink" title="* 对元素增加onClick是否合理"></a>* 对元素增加onClick是否合理</h3><p>在学习jQuery的时候，一直避免在HTML元素上直接绑定<code>onclick</code>方法，HTML绑定<code>onclick</code>方法问题有很多，像：不方便管理、在删除DON的时候使用<code>removeEventListener</code>注销相关事件处理器等。但React的<code>onClick</code>不同于在HTML上的<code>onclick</code>，<del>因为它的C是大写的</del>，因为它只存在于组件的生命周期内，每个组件的<code>onClick</code>都会在组件卸载（unmount）时清除。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟DOM（Virtual DOM）可以看做是对DOM的抽象，当React进行重复渲染来进行DON修改完成用户交互时，并不需要需改组件的全部DOM，它会比对本次的虚拟DOM与上次的虚拟DOM，找出真正需要修改的DOM点进行修改。这种渲染最少DOM方式的效率在当前项目中不需要担心。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>React中最需要学习的点，React在渲染的过程中，会按照流程调用各生命周期函数，所以一些逻辑处理可以在各生命周期函数中进行，生命周期的大体流程可见<a href="https://segmentfault.com/a/1190000011694925" target="_blank" rel="noopener">了解React组件生命周期</a></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>使用ES6来写React能带来不少便捷，例如使用箭头函数会自动绑定this等（不知道该不该推荐这样使用），但当前部分浏览器并不支持ES6,所以需要转义成ES5，转义方式以后再分析，当然，ES6不是必需的，也可以直接使用ES5语言来编写，但强烈建议学习或者了解一下ES6。ES6语法的学习可以见参考文章的ECMAScript 6 入门。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/libin-1/p/6013490.html" target="_blank" rel="noopener">JavaScript常见的内存泄漏原因</a></li><li><a href="https://www.cnblogs.com/polk6/p/5097334.html" target="_blank" rel="noopener">HTML 事件(二) 事件的注册与注销</a></li><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li><li>深入浅出React和Redux</li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> FreshMan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记-索引</title>
      <link href="/2018/04/04/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/04/04/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>用react有一段时间（&lt;= 3Months），主要用到了react的生命周期、父子组件通信、与其他组件结合使用等等。这一章为笔记索引。<br><a id="more"></a></p><h2 id="1、react是什么，为什么要替换jQuery"><a href="#1、react是什么，为什么要替换jQuery" class="headerlink" title="1、react是什么，为什么要替换jQuery"></a>1、react是什么，为什么要替换jQuery</h2><p>思考了一下<strong>自己</strong>jQuery项目中遇到的使自己感到处理很复杂的问题，如果用react会不会简单；jQuery与react的区别是什么？JSX？虚拟DOM？生命周期？ES6？。</p><h2 id="2、react最主要的生命周期"><a href="#2、react最主要的生命周期" class="headerlink" title="2、react最主要的生命周期"></a>2、react最主要的生命周期</h2><p>我要在何时给界面一个初始值；当内容变化时，我该在哪里控制界面重新渲染；为啥我的界面陷入了死循环……</p><h2 id="3、react父子组件如何通信"><a href="#3、react父子组件如何通信" class="headerlink" title="3、react父子组件如何通信"></a>3、react父子组件如何通信</h2><p>能接收父组件的传参吗？子组件想要给父组件返回值呢？</p><h2 id="4、react-ES6-babel转义"><a href="#4、react-ES6-babel转义" class="headerlink" title="4、react ES6 babel转义"></a>4、react ES6 babel转义</h2><p>啊哦，浏览器不支持ES6；咦，为什么我的前台界面渲染这么慢（前端解析ES6能不慢么）</p><h2 id="5、react-jQuery-jQuery组件应用等"><a href="#5、react-jQuery-jQuery组件应用等" class="headerlink" title="5、react+jQuery jQuery组件应用等"></a>5、react+jQuery jQuery组件应用等</h2><p>好纠结，原项目用jQuery封装好的方法类要不要重新写？不写的话我该怎么用？</p><h2 id="6、react-Ajax-后台交互，绑定变量等"><a href="#6、react-Ajax-后台交互，绑定变量等" class="headerlink" title="6、react+Ajax 后台交互，绑定变量等"></a>6、react+Ajax 后台交互，绑定变量等</h2><p>我想要找后台讨论一下当前条件下的查询结果，我该咋办？震惊！你还在用Ajax？</p><h2 id="7、react-Echarts-数据渲染等"><a href="#7、react-Echarts-数据渲染等" class="headerlink" title="7、react+Echarts 数据渲染等"></a>7、react+Echarts 数据渲染等</h2><p>“看别人的统计界面，折线图、柱状图、饼图各种直观化图形界面，看看你的，一堆数字表格，退回重做！”</p><h2 id="8、react-Antd-前台样式库"><a href="#8、react-Antd-前台样式库" class="headerlink" title="8、react+Antd 前台样式库"></a>8、react+Antd 前台样式库</h2><p>当你作为一个伪全栈，费劲所剩不多的脑子去搞前台样式时，不妨试一下Antd，即使样式不满足需求，至少可以提供思路。</p><h2 id="8、react-redux"><a href="#8、react-redux" class="headerlink" title="8、react+redux"></a>8、react+redux</h2><p>如何保证数据一致性？Flux is what？redux2333，</p><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> FreshMan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle 数据库服务停启</title>
      <link href="/2018/02/23/Oracle-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%81%9C%E5%90%AF/"/>
      <url>/2018/02/23/Oracle-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%81%9C%E5%90%AF/</url>
      <content type="html"><![CDATA[<p>数据库服务宕掉该如何重启<br><a id="more"></a></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="查看数据库状态"><a href="#查看数据库状态" class="headerlink" title="查看数据库状态"></a>查看数据库状态</h4><pre><code>sqlplus / as sysdbaSELECT status FROM V$INSTANCE;</code></pre><p>查询报：<code>ORA-01034</code>则表示数据库服务未启动</p><h4 id="数据库服务关闭"><a href="#数据库服务关闭" class="headerlink" title="数据库服务关闭"></a>数据库服务关闭</h4><ol><li>SHUTDOWN IMMEDIATE<br>会中断正在执行的SQL语句，并将未提交的事务进行回滚，断开所有连接的用户</li><li>SHUTDOWN NORMAL<br>不允许新建连接，等待现有连接用户全部退出之后才关闭数据库。下次启动不需要进行任何实例恢复。</li><li><p>SHUTDOWN ABORT<br>类似于强制关闭，会中断正在执行的SQL语句，且不回滚未提交的事务。下次启动时需要进行实例恢复，启动时可能耗时较长。一般在如下场景使用该命令：  </p><ol><li>数据库处于一种非正常工作状态，不能用shutdown normal或者shutdown immediate这样的命令关闭数据库;</li><li>需要立即关闭数据库；</li><li>在启动数据库实例时遇到问题；</li></ol></li></ol><p>有关于checkPoint的知识点尚未接触，暂无。</p><h4 id="数据库服务启动"><a href="#数据库服务启动" class="headerlink" title="数据库服务启动"></a>数据库服务启动</h4><ol><li>STARTUP NOMOUNT<br>仅创建一个oracle实例，读取init.ora初始化参数文件、启动后台进程、初始化系统全局区（SGA）。需要继续执行以下命令才能打开数据库：<pre><code>ALTER DATABASE MOUNT;ALTER DATABASE OPEN;</code></pre></li><li>STARTUP MOUNT<br>创建实例并且挂载数据库，但没有打开数据库。 需要继续执行以下命令才能打开数据库：<pre><code>ALTER DATABASE OPEN;</code></pre></li><li>STARTUP<br>该命令包含：创建实例、挂载实例、打开数据库的所有步骤。成功结束后数据库系统便处于正常工作状态，可以接受用户请求。<br><img src="https://github.com/francisXKF/francisXKF.github.io/tree/master/images/orcle-startup.png" alt="STARTUP启动成功"></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/guohu/p/4253418.html" target="_blank" rel="noopener">Oracle数据库实例的启动及关闭</a></p>]]></content>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OGG服务同步数据</title>
      <link href="/2018/02/10/OGG%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/02/10/OGG%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>想要通过OGG方式实现正式库的修改数据同步到备库中<br><a id="more"></a><br>前提：  </p><ul><li>Oracle 10g</li><li>OGG服务已安装</li><li>两个数据库已有相同用户</li><li>待同步的表已完成主备一致</li></ul><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><p>问题1：连接备库时，报<code>ora-12514 监听程序无法识别连接操作符中请求的服务</code><br>解决：查看<code>$ORACLE_HOME/network/admin</code>目录下没有<code>listener.ora</code>文件，参考其他数据库主机配置，新建了该文件，并写入以下内容，执行<code>lsnrctl status</code>查看监听状态，<code>lsnrctl stop</code>停止监听，<code>lsnrctl start</code>启动监听：</p><pre><code># listener.ora Network Configuration File: /oracle/product/10.2.0/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER =  (SID_LIST =    (SID_DESC =      (SID_NAME = DBSID)      (ORACLE_HOME = ORACLE_HOME)    )  )LISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = TCP)(HOST = HOST_IP)(PORT = 1521))      (ADDRESS = (PROTOCOL = IPC)(KEY = DBSID))    )  )</code></pre><p>其中：</p><ul><li><code>SID_NAME</code>处，DBSID为Oracle实例iD，可以通过<code>echo $ORACLE_SID</code>来查看，若该环境变量未配置，可以通过<code>ps -ef | grep ora_</code>查看最后一个单词来进行分析</li><li><code>ORACLE_HOME</code>处，ORACLE_HOME应填上具体路径，与<code>echo $ORACLE_HOME</code>相同</li><li><code>HOST</code>处，填写数据库主机IP，如<code>10.131.23.10</code></li><li><code>KEY = DBSID</code>处，DBSID与<code>SID_NAME</code>处填写的一致</li></ul></li><li><p>问题2：报<code>ORA-01034</code>和<code>ORA-27101</code><br>解决：基本就是数据库挂了，需要使用oracle用户登录主机，使用sysdba登录数据库，启动数据库</p><pre><code>sqlplus / as sysdba # 使用sysdba登录数据库startup # 启动数据库</code></pre></li><li><p>问题3：执行./ggsci时报<code>libnnz10.so No such file or directory</code><br>解决：由于环境变量中没有加入<code>$ORACLE_HOME/lib</code>导致</p><pre><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib</code></pre></li><li><p>问题4：启动OGG服务<br>解决：</p><pre><code># 启动cd $GG_HOME./ggscistart mgrstart *# 停止stop *stop mgr</code></pre></li><li><p>问题5：OGG服务启动后，修改正式库表记录，但备库未同步<br>解决：由于replicat服务ABENDED导致不同步，需要修改读检查点和写检查点，尚未完成学习</p></li><li><p>问题6：replicat服务ABENDED<br>解决：通过以下命令找到出问题的点：</p><pre><code>info allinfo REP_group #REP_group为要查询的REPLICAT的GROUP名sh more ggserr.log #查看日志文件</code></pre><p>可以键入v进入vim视图，通过G来到达最后一行查看最近报错信息。</p></li><li><p>问题7：查看REPLICAT进程的参数设置与状态  </p><pre><code>view params REP_group #REP_group为要查询的REPLICAT的GROUP名info REP_group detail #可以查看Error log文件的位置等</code></pre><p>详细可以看参考文章的<a href="http://blog.csdn.net/lqx0405/article/details/44777515" target="_blank" rel="noopener">Oracle GoldenGate学习之–GoldenGate的监控</a></p></li><li><p>问题8：处理ABANDON状态进程</p><pre><code>./ggsciinfo allinfo REP_groupsh ls ./dirrpt -l #查看最近程序执行的日志文件名sh more ./dirrpt/rep_group.dsc #查看最近日志文件内容，一般含有异常记录的描述./logdumpopen ./dirdat/jz000012 #进入logdump查看最近检查点alter replicat rep_group,extseqno 19,extrba 15042355 #修改检查点stop *start *</code></pre></li></ul><p>Tips：若能确认abandon状态中源主机没有任何操作，或许可以直接将检查点修改为<code>info REP_GROUP</code>里展示的检查点，19对应File的后缀，extrba对应RBA：</p><blockquote><p>Log Read Checkpoint  File ./dirdat/jz000019<br>                    2018-03-12 10:22:49.678621  RBA 15042355</p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://blog.csdn.net/u013519551/article/details/53485342" target="_blank" rel="noopener">ORA-01034和ORA-27101的解决方法</a><br><a href="http://blog.sina.com.cn/s/blog_6f7b73770101b6l5.html" target="_blank" rel="noopener">解决 ORA-12514: TNS: 监听程序当前无法识别连接描述符中请求的服务</a><br><a href="http://blog.csdn.net/eviswang/article/details/51034727" target="_blank" rel="noopener">./ggsci: error while loading shared libraries: libnnz11.so: cannot open shared object file: No such</a><br><a href="http://blog.csdn.net/lqx0405/article/details/44777515" target="_blank" rel="noopener">Oracle GoldenGate学习之–GoldenGate的监控</a><br><a href="http://blog.csdn.net/lbyyy/article/details/51775478" target="_blank" rel="noopener">OGG故障排除1例：因B机被修改数据导致replicat服务ABENDED修复</a><br><a href="https://www.cnblogs.com/tan-java/p/5613248.html" target="_blank" rel="noopener">ogg logdump工具使用介绍</a></p>]]></content>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+github简单命令</title>
      <link href="/2018/02/10/hexo-github%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/02/10/hexo-github%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h3><h4 id="创建文章、标签等"><a href="#创建文章、标签等" class="headerlink" title="创建文章、标签等"></a>创建文章、标签等</h4><ul><li>hexo new “postName” #新建文章</li><li>hexo new page “pageName” #新建页面</li></ul><h4 id="修改文章发布、同步到github等"><a href="#修改文章发布、同步到github等" class="headerlink" title="修改文章发布、同步到github等"></a>修改文章发布、同步到github等</h4><ul><li>hexo p == hexo publish</li><li>hexo g == hexo generate #生成</li><li>hexo s == hexo server #启动服务预览</li><li>hexo d == hexo deploy # 部署到github</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo常用命令笔记</a><br><a href="https://segmentfault.com/q/1010000002561642" target="_blank" rel="noopener">hexo分类与tags配置</a></p>]]></content>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FirstBlog</title>
      <link href="/2018/02/08/FirstBlog/"/>
      <url>/2018/02/08/FirstBlog/</url>
      <content type="html"><![CDATA[<p>第一次使用<code>hexo</code>+<code>GitHub</code>的方式搭建个人博客，如果不搞各种插件的话，搭起来还是比较简单的，不过…确定<del>有定力</del>不去尝试各种插件么？<br><a id="more"></a></p><p>流程大概就是：</p><ol><li>观望<code>GitHub</code>对<code>hexo</code>与<code>jekyll</code>的支持程度，最终选择了自己曾经<strong>见过</strong>的<code>hexo</code></li><li>在<code>Github</code>上建立个人博客repository。这部分比较<del>简单</del>，主要纠结在了不断的404上。</li><li>主机上原来各种捣鼓都装上了Node.js、git这一堆东西</li><li><code>hexo init</code>开始装上了hexo，摸索了一下hexo结构</li><li>大概最纠结的事情出现了：找主题。前后试过<code>landscape</code>、<code>next</code>、<code>maupassant</code>、<code>light</code>，最喜欢的样式是<code>light</code>，在用的是<code>maupassant</code>。感觉<code>next</code>动画很足，缺点也是动画导致整体渲染看起来比较慢；<code>light</code>的样式看起来舒服，不足是提供的功能真的有点儿少……</li><li>花了一顿晚饭钱买了个域名，在考虑要不要注一个<code>.com</code>的。</li><li><a href="https://tongji.baidu.com/open/" target="_blank" rel="noopener">百度统计</a>、<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a>、七牛、又拍等</li></ol><p>下一步计划？或者说是期望：  </p><ul><li>增加评论功能（现在没有，找我的话通过Github吧~）</li><li>租个云服务器做自己的后台服务</li><li>动手写一个前后端交互的页面</li><li>考虑如何将内容同步到简书或者segmentfault</li></ul><p>END……</p>]]></content>
      
      <categories>
          
          <category> Whisper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lambda实现switch</title>
      <link href="/2018/02/08/lambda%E5%AE%9E%E7%8E%B0switch/"/>
      <url>/2018/02/08/lambda%E5%AE%9E%E7%8E%B0switch/</url>
      <content type="html"><![CDATA[<p>根据输入的条件符号，对两个输入的数字进行表达式判断<br><a id="more"></a></p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>查了查网上资料，总体有三种方案实现：<br>1、<strong>字典+函数</strong><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">(x)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">...</span><br><span class="line">funcDict&#123;</span><br><span class="line">    <span class="string">'A'</span> : funcA,</span><br><span class="line">    <span class="string">'B'</span> : funcB,</span><br><span class="line">    <span class="string">'C'</span> : funcC</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">funcDict.get(value, funcDefault)(x)</span><br></pre></td></tr></table></figure></p><p>2、<strong>字典+lambda</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lambdaDict&#123;</span><br><span class="line"><span class="code">    'A' : lambda x : x,</span></span><br><span class="line"><span class="code">    'B' : lambda x : x,</span></span><br><span class="line"><span class="code">    'C' : lambda x : x</span></span><br><span class="line">&#125;[<span class="string">value</span>](<span class="link">x</span>)</span><br></pre></td></tr></table></figure></p><p>3、Brian Beck提供了一个类 switch 来实现其他语言中switch的功能</p><p>由于要实现的功能是两个数之间根据输入的表达式来进行比较，所以选择了写起来比较简洁（自认为简洁）的lambda<br><strong>样例</strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def opJudge(processCnt, op, expectCnt):</span><br><span class="line">    judgeAns = &#123;</span><br><span class="line">        <span class="string">'='</span> : <span class="type">lambda</span> x, y : <span class="type">x</span> == y,</span><br><span class="line">        <span class="string">'&gt;'</span> : <span class="type">lambda</span> x, y : <span class="type">x</span> &gt; y,</span><br><span class="line">        <span class="string">'&lt;'</span> : <span class="type">lambda</span> x, y : <span class="type">x</span> &lt; y,</span><br><span class="line">        '&gt;=' : <span class="type">lambda</span> x, y : <span class="type">x</span> &gt;= y,</span><br><span class="line">        '&lt;=' : <span class="type">lambda</span> x, y : <span class="type">x</span> &lt;= y,</span><br><span class="line">        '!=' : <span class="type">lambda</span> x, y : <span class="type">x</span> != y,</span><br><span class="line">    &#125;[op](processCnt, expectCnt)</span><br><span class="line">    <span class="keyword">return</span> judgeAns</span><br></pre></td></tr></table></figure></p><p><small>写的时候对lambda的认识：lambda后面紧跟的是<strong>形参</strong>，就是func(x, y)里面的x、y，冒号后面的是<strong>方法</strong>，就是func(…){method}里面的method</small></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/suiyunonghen/article/details/3734135" target="_blank" rel="noopener">Python中Swithch Case语法实现</a><br><a href="http://blog.csdn.net/mathboylinlin/article/details/9413551" target="_blank" rel="noopener">Python学习笔记（十二）：lambda表达式与函数式编程</a></p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
