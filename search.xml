<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux-内存分析</title>
      <link href="/2018/05/08/Linux-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/08/Linux-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>分析Linux内存使用情况，包括：<code>free</code>命令展示内容分析；<code>top</code>命令中内存部分分析；<code>/proc/meminfo</code>中内存部分分析；<br><a id="more"></a></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>想要对线上主机的进程占用内存情况进行监控，原来很简单的使用的是<code>free</code>命令的<code>used</code>来表示的内存使用情况，目前已不能满足监控要求，需要分析<code>free</code>、<code>top</code>、<code>/proc/meminfo</code>各字段含义，以及找出符合需求的方案。</p><h2 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a><code>free</code>命令</h2><p><code>free</code>命令输出格式如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[~]$ free -k</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:      <span class="number">49449300</span>   <span class="number">24798084</span>   <span class="number">24651216</span>          <span class="number">0</span>    <span class="number">3602016</span>   <span class="number">15910220</span></span><br><span class="line">-/+ buffers/cache:    <span class="number">5285848</span>   <span class="number">44163452</span></span><br><span class="line">Swap:     <span class="number">33554424</span>   <span class="number">14794692</span>   <span class="number">18759732</span></span><br></pre></td></tr></table></figure></p><ul><li>Mem<ul><li>total：内存总量</li><li>used：内存使用量，包含<code>buffers</code>与<code>cached</code></li><li>free：空闲内存量</li><li>buffers、cached：缓存内存量</li></ul></li><li>-/+ buffers/cache<ul><li>used：used – buffers – cached</li><li>free：free + buffers + cached</li></ul></li><li>Swap：交换区</li></ul><p>存在的关系为：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mem：total = used + free</span><br><span class="line">     实际已用内存 = total - <span class="keyword">buffers </span>- <span class="keyword">cached</span></span><br><span class="line"><span class="keyword"> </span>    空闲内存 = free + <span class="keyword">buffers </span>+ <span class="keyword">cached</span></span><br></pre></td></tr></table></figure></p><p>还有另一种<code>free</code>命令结果：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[~]$ free -k</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:     <span class="number"> 263848376 </span>  <span class="number"> 21822408 </span>    <span class="number"> 836740 </span>    <span class="number"> 968264 </span> <span class="number"> 241189228 </span>  240590568</span><br><span class="line">Swap:    <span class="number"> 134217724 </span>    <span class="number"> 562320 </span>  133655404</span><br></pre></td></tr></table></figure></p><p>与上一种不同的是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mem</span><br><span class="line">  used为实际使用量</span><br><span class="line">  total = used + <span class="built_in">free</span> + buff/cache</span><br><span class="line">  available = 可回收的内存 + <span class="built_in">free</span> 表示系统可用的内存，不过这是一个估计值，并不精确</span><br></pre></td></tr></table></figure></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a><code>top</code>命令</h2><p><code>top</code>命令输出格式如下：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[~]$ top</span><br><span class="line">top - 23:29:48 up<span class="number"> 699 </span>days,  7:17, <span class="number"> 6 </span>users,  load average: 1.65, 1.30, 1.22</span><br><span class="line">Tasks:<span class="number"> 773 </span>total,  <span class="number"> 1 </span>running,<span class="number"> 772 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">Cpu(s):  3.6%us,  2.8%sy,  0.0%ni, 93.5%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:  49449300k total, 24823852k used, 24625448k free,  3602116k buffers</span><br><span class="line">Swap: 33554424k total, 14794692k used, 18759732k free, 15911860k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">22326 root     <span class="number"> 18 </span> <span class="number"> 0 </span>9963m 679m<span class="number"> 2472 </span>S 100.7  1.4 167891:08 java   </span><br><span class="line">27893 aiuap_jc <span class="number"> 15 </span> <span class="number"> 0 </span>13272<span class="number"> 1616 </span><span class="number"> 808 </span>R  1.0  0.0   0:00.06 top     </span><br><span class="line">   <span class="number"> 1 </span>root     <span class="number"> 15 </span> <span class="number"> 0 </span>10348  <span class="number"> 96 </span> <span class="number"> 64 </span>S  0.0  0.0  29:29.83 init</span><br></pre></td></tr></table></figure></p><p>其中Mem行与Swap行与<code>free</code>命令输出结果能够一一对应<br>对于每个进程来说：</p><h3 id="VIRT"><a href="#VIRT" class="headerlink" title="VIRT"></a>VIRT</h3><p>virtual memory usage 虚拟内存<br>进程需要的虚拟内存大小，并不是实际占用的物理内存大小，包括了进程使用的库、代码、数据等</p><blockquote><p>假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量</p></blockquote><h3 id="RES"><a href="#RES" class="headerlink" title="RES"></a>RES</h3><p>resident memory usage 常驻内存<br>进程当前使用的内存，<strong>包括与其他程序的共享内存</strong>，但不包括swap out</p><blockquote><p>如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反<br>关于库占用内存的情况，它只统计加载的库文件所占内存大小</p></blockquote><h3 id="SHR"><a href="#SHR" class="headerlink" title="SHR"></a>SHR</h3><p>shared memory 共享内存<br>当前进程自身/其他进程的共享内存  </p><blockquote><p>虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小</p></blockquote><p>某个进程独占的物理内存大小 = RES – SHR</p><h3 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h3><p><code>top</code>命令还有一个<code>DATA</code>一项（需要f手工添加），表示该程序数据占用的内存。</p><h2 id="proc-meminfo"><a href="#proc-meminfo" class="headerlink" title="/proc/meminfo"></a><code>/proc/meminfo</code></h2><p><code>/proc/meminfo</code>内容如下：<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[~]$ cat /<span class="keyword">proc</span>/meminfo</span><br><span class="line">MemTotal:       263848376<span class="title"> kB</span></span><br><span class="line"><span class="title">MemFree:</span>          768316<span class="title"> kB</span></span><br><span class="line"><span class="title">MemAvailable:</span>   240574824<span class="title"> kB</span></span><br><span class="line"><span class="title">Buffers:</span>          377792<span class="title"> kB</span></span><br><span class="line"><span class="title">Cached:</span>         233359392<span class="title"> kB</span></span><br><span class="line"><span class="title">SwapCached:</span>         1480<span class="title"> kB</span></span><br><span class="line"><span class="title">Active:</span>         139386604<span class="title"> kB</span></span><br><span class="line"><span class="title">Inactive:</span>       114406100<span class="title"> kB</span></span><br><span class="line"><span class="title">Active(anon):</span>   19662812<span class="title"> kB</span></span><br><span class="line"><span class="title">Inactive(anon):</span>  1360920<span class="title"> kB</span></span><br><span class="line"><span class="title">Active(file):</span>   119723792<span class="title"> kB</span></span><br><span class="line"><span class="title">Inactive(file):</span> 113045180<span class="title"> kB</span></span><br><span class="line"><span class="title">Unevictable:</span>           0<span class="title"> kB</span></span><br><span class="line"><span class="title">Mlocked:</span>               0<span class="title"> kB</span></span><br><span class="line"><span class="title">SwapTotal:</span>      134217724<span class="title"> kB</span></span><br><span class="line"><span class="title">SwapFree:</span>       133655284<span class="title"> kB</span></span><br><span class="line"><span class="title">Dirty:</span>            107808<span class="title"> kB</span></span><br><span class="line"><span class="title">Writeback:</span>             0<span class="title"> kB</span></span><br><span class="line"><span class="title">AnonPages:</span>      20054452<span class="title"> kB</span></span><br><span class="line"><span class="title">Mapped:</span>            34972<span class="title"> kB</span></span><br><span class="line"><span class="title">Shmem:</span>            968144<span class="title"> kB</span></span><br><span class="line"><span class="title">Slab:</span>            7506700<span class="title"> kB</span></span><br><span class="line"><span class="title">SReclaimable:</span>    7375420<span class="title"> kB</span></span><br><span class="line"><span class="title">SUnreclaim:</span>       131280<span class="title"> kB</span></span><br><span class="line"><span class="title">KernelStack:</span>        6240<span class="title"> kB</span></span><br><span class="line"><span class="title">PageTables:</span>        47808<span class="title"> kB</span></span><br><span class="line"><span class="title">NFS_Unstable:</span>          0<span class="title"> kB</span></span><br><span class="line"><span class="title">Bounce:</span>                0<span class="title"> kB</span></span><br><span class="line"><span class="title">WritebackTmp:</span>          0<span class="title"> kB</span></span><br><span class="line"><span class="title">CommitLimit:</span>    266141912<span class="title"> kB</span></span><br><span class="line"><span class="title">Committed_AS:</span>   27851440<span class="title"> kB</span></span><br><span class="line"><span class="title">VmallocTotal:</span>   34359738367<span class="title"> kB</span></span><br><span class="line"><span class="title">VmallocUsed:</span>      733404<span class="title"> kB</span></span><br><span class="line"><span class="title">VmallocChunk:</span>   34222675168<span class="title"> kB</span></span><br><span class="line"><span class="title">HardwareCorrupted:</span>     0<span class="title"> kB</span></span><br><span class="line"><span class="title">AnonHugePages:</span>   5552128<span class="title"> kB</span></span><br><span class="line"><span class="title">HugePages_Total:</span>       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048<span class="title"> kB</span></span><br><span class="line"><span class="title">DirectMap4k:</span>      129792<span class="title"> kB</span></span><br><span class="line"><span class="title">DirectMap2M:</span>     3936256<span class="title"> kB</span></span><br><span class="line"><span class="title">DirectMap1G:</span>    266338304<span class="title"> kB</span></span><br></pre></td></tr></table></figure></p><p>这部分内容基本是根据<a href="http://linuxperf.com/?p=142" target="_blank" rel="noopener">/PROC/MEMINFO之谜</a>进行学习的，建议看原文章，本节下面的内容主要是便于自身理解。<br>其中：</p><h3 id="MemTotal"><a href="#MemTotal" class="headerlink" title="MemTotal"></a>MemTotal</h3><p>可供支配的总内存大小</p><h3 id="MemFree"><a href="#MemFree" class="headerlink" title="MemFree"></a>MemFree</h3><p>尚未使用的内存，MemTotal-MemFree表示已经用过的内存，但不等于可用内存，因为有部分内存可回收释放</p><h3 id="MemAvailable"><a href="#MemAvailable" class="headerlink" title="MemAvailable"></a>MemAvailable</h3><p>可用内存，这是内核估算出来的值，并不十分精确，等于部分可回收的内存+MemFree</p><h3 id="PageTables"><a href="#PageTables" class="headerlink" title="PageTables"></a>PageTables</h3><p>Page Table用于将内存的虚拟地址翻译成物理地址，随着内存地址分配得越来越多，Page Table会增大，pageTables表示Page Table的大小</p><h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><p>表示块设备(block device)所占用的缓存页，包括：直接读写块设备、以及文件系统元数据(metadata)比如SuperBlock所使用的缓存页；<br>这部分可以理解为直接与块设备进行读写，所以需要缓存页的使用，例如使用dd命令进行复制等。因为块设备的读写是按照块来进行的，引入缓冲区后，可以避免小数据量的改动导致重复对块（可能是块下的扇区）进行读写，提高效率。</p><h3 id="Cached"><a href="#Cached" class="headerlink" title="Cached"></a>Cached</h3><p>包括正被用户使用到的文件的缓存页+原用过但并没有回收的页面，即包括：Mapped与unmapped的页面。</p><h3 id="SwapCached"><a href="#SwapCached" class="headerlink" title="SwapCached"></a>SwapCached</h3><p>交换区缓存，是交换区设备的缓存。</p><blockquote><p>交换区可以包括一个或多个交换区设备（裸盘、逻辑卷、文件都可以充当交换区设备），每一个交换区设备都对应自己的swap cache，可以把swap cache理解为交换区设备的”page cache”：page cache对应的是一个个文件，swap cache对应的是一个个交换区设备，kernel管理swap cache与管理page cache一样，用的都是radix-tree，唯一的区别是：page cache与文件的对应关系在打开文件时就确定了，而一个匿名页只有在即将被swap-out的时候才决定它会被放到哪一个交换区设备，即匿名页与swap cache的对应关系在即将被swap-out时才确立。  </p><p>并不是每一个匿名页都在swap cache中，只有以下情形之一的匿名页才在：  </p><p>匿名页即将被swap-out时会先被放进swap cache，但通常只存在很短暂的时间，因为紧接着在pageout完成之后它就会从swap cache中删除，毕竟swap-out的目的就是为了腾出空闲内存；<br>【注：参见mm/vmscan.c: shrink_page_list()，它调用的add_to_swap()会把swap cache页面标记成dirty，然后它调用try_to_unmap()将页面对应的page table mapping都删除，再调用pageout()回写dirty page，最后try_to_free_swap()会把该页从swap cache中删除。】<br>曾经被swap-out现在又被swap-in的匿名页会在swap cache中，直到页面中的内容发生变化、或者原来用过的交换区空间被回收为止。<br>【注：当匿名页的内容发生变化时会删除对应的swap cache，代码参见mm/swapfile.c: reuse_swap_page()。】  </p><p>/proc/meminfo中的SwapCached背后的含义是：系统中有多少匿名页曾经被swap-out、现在又被swap-in并且swap-in之后页面中的内容一直没发生变化。也就是说，如果这些匿名页需要被swap-out的话，是无需进行I/O write操作的。</p></blockquote><p>需要注意的是，<code>Cached</code>与<code>SwapCached</code>两个统计值是互不重叠的，Shared memory和tmpfs在不发生swap-out的时候属于”Cached”，而在swap-out/swap-in的过程中会被加进swap cache中、属于”SwapCached”，一旦进了”SwapCached”，就不再属于”Cached”了。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><blockquote><p>用户进程的内存页分为两种：file-backed pages（与文件对应的内存页），和anonymous pages（匿名页），比如进程的代码、映射的文件都是file-backed，而进程的堆、栈都是不与文件相对应的、就属于匿名页。file-backed pages在内存不足的时候可以直接写回对应的硬盘文件里，称为page-out，不需要用到交换区(swap)；而anonymous pages在内存不足时就只能写到硬盘上的交换区(swap)里，称为swap-out。  </p><p>file 表示 file-backed pages（与文件对应的内存页）</p></blockquote><p>理论上应该有：<br><strong>【所有进程的PSS之和】 == 【Mapped + AnonPages】</strong></p><blockquote><p>实际测试的结果，虽然两者很接近，却总是无法精确相等，我猜也许是因为进程始终在变化、采集的/proc/[1-9]*/smaps以及/proc/meminfo其实不是来自同一个时间点的缘故。</p></blockquote><h3 id="Shmem"><a href="#Shmem" class="headerlink" title="Shmem"></a>Shmem</h3><p>主要包括：</p><ul><li>shared memory（基于tmpfs实现）</li><li>tmpfs  </li></ul><p>Shmem 统计的是已经分配的大小，而不是创建时申请的大小</p><h3 id="AnonPages"><a href="#AnonPages" class="headerlink" title="AnonPages"></a>AnonPages</h3><ul><li>所有page cache里的页面(Cached)都是file-backed pages，不是Anonymous Pages。”Cached”与”AnoPages”之间没有重叠。<br>注：shared memory 不属于 AnonPages，而是属于Cached，因为shared memory基于tmpfs，所以被视为file-backed、在page cache里，上一节解释过。</li><li>mmap private anonymous pages属于AnonPages(Anonymous Pages)，而mmap shared anonymous pages属于Cached(file-backed pages)，因为shared anonymous mmap也是基于tmpfs的。</li><li>Anonymous Pages是与用户进程共存的，一旦进程退出，则Anonymous pages也释放，不像page cache即使文件与进程不关联了还可以缓存。</li><li>AnonPages统计值中包含了Transparent HugePages (THP)对应的 AnonHugePages</li></ul><h3 id="Mapped"><a href="#Mapped" class="headerlink" title="Mapped"></a>Mapped</h3><p>用户进程的file-backed pages就对应着/proc/meminfo中的”Mapped”</p><blockquote><p>正被用户进程关联，比如shared libraries、可执行程序的文件、mmap的文件等，这些文件的缓存页就称为mapped  </p><p>”Mapped”是”Cached”的子集</p></blockquote><h3 id="主要关系图"><a href="#主要关系图" class="headerlink" title="主要关系图"></a>主要关系图</h3><p><code>/proc/meminfo</code>中主要字段关系为，这个图描述可能过于简洁，导致一些地方存在偏差，只是提供分析方法。<br><img src="https://upload-images.jianshu.io/upload_images/6101555-c5e0fc1ffe940439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="Linux中meminfo相关信息关系"></p><h2 id="proc-pid-smaps"><a href="#proc-pid-smaps" class="headerlink" title="/proc/pid/smaps"></a>/proc/pid/smaps</h2><p>每个进程都有的文件，记录了进程信息，其中有内存使用情况。</p><p>如果要统计所有进程占用的内存，并且共享内存不重复记录，则可以通过：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep Pss /<span class="function"><span class="keyword">proc</span>/[<span class="number">1</span><span class="number">-9</span>]*/<span class="title">smaps</span> | <span class="title">awk</span>  '&#123;<span class="title">total</span>+=$<span class="number">2</span>&#125;</span>; <span class="keyword">END</span> &#123;<span class="keyword">print</span> total&#125;'</span><br></pre></td></tr></table></figure></p><p>需要注意的是，可能有的pid下的/smaps没有权限访问……</p><p>同时：top命令输出中的RES和pmap输出中的RSS是一个东西</p><h2 id="各命令之间的关系比对"><a href="#各命令之间的关系比对" class="headerlink" title="各命令之间的关系比对"></a>各命令之间的关系比对</h2><p>top<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[~]$ top</span><br><span class="line">top - <span class="number">00</span>:<span class="number">15</span>:<span class="number">31</span> up <span class="number">699</span> days,  <span class="number">8</span>:<span class="number">03</span>,  <span class="number">6</span> users,  load average: <span class="number">1</span>.<span class="number">65</span>, <span class="number">1</span>.<span class="number">27</span>, <span class="number">1</span>.<span class="number">24</span></span><br><span class="line">Tasks: <span class="number">780</span> total,<span class="number">5</span> running, <span class="number">775</span> sleeping,<span class="number">0</span> stopped,<span class="number">0</span> zombie</span><br><span class="line">Cpu(s):  <span class="number">6</span>.<span class="number">3</span>%us,  <span class="number">4</span>.<span class="number">7</span>%sy,  <span class="number">0</span>.<span class="number">0</span>%ni, <span class="number">88</span>.<span class="number">5</span>%id,  <span class="number">0</span>.<span class="number">6</span>%wa,  <span class="number">0</span>.<span class="number">0</span>%hi,  <span class="number">0</span>.<span class="number">0</span>%si,  <span class="number">0</span>.<span class="number">0</span>%st</span><br><span class="line">Mem:  <span class="number">49449300</span>k total, <span class="number">24825488</span>k used, <span class="number">24623812</span>k free,  <span class="number">3602140</span>k buffers</span><br><span class="line">Swap: <span class="number">33554424</span>k total, <span class="number">14794692</span>k used, <span class="number">18759732</span>k free, <span class="number">15912372</span>k cached</span><br><span class="line"></span><br><span class="line">  PID USERPR  NI  VIRT  RES  SHR S %CPU %MEM TIME+  COMMAND  </span><br><span class="line"><span class="number">22326</span> root180 <span class="number">9963m</span> <span class="number">662m</span> <span class="number">2472</span> S <span class="number">101</span>.<span class="number">0</span>  <span class="number">1.4 167937</span>:<span class="number">49</span> java  </span><br><span class="line"><span class="number">17775</span> app_usr160  <span class="number">247m</span>  <span class="number">12m</span> <span class="number">5276</span> S  <span class="number">1</span>.<span class="number">3</span>  <span class="number">0.00:00.57</span> python</span><br><span class="line"><span class="number">18304</span> app_usr<span class="number">150 13272</span> <span class="number">1644</span>  <span class="number">808</span> R  <span class="number">0</span>.<span class="number">7</span>  <span class="number">0.00:00.05</span> top</span><br><span class="line"><span class="number">18426</span> app_usr180  <span class="number">247m</span>  <span class="number">11m</span> <span class="number">3776</span> R  <span class="number">0</span>.<span class="number">7</span>  <span class="number">0.00:00.02</span> python</span><br><span class="line"><span class="number">18425</span> app_usr180  <span class="number">247m</span>  <span class="number">11m</span> <span class="number">3776</span> R  <span class="number">0</span>.<span class="number">3</span>  <span class="number">0.00:00.01</span> python</span><br></pre></td></tr></table></figure></p><p>free<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[~]$ free -k</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:      <span class="number">49449300</span>   <span class="number">24820228</span>   <span class="number">24629072</span>          <span class="number">0</span>    <span class="number">3602140</span>   <span class="number">15912372</span></span><br><span class="line">-/+ buffers/cache:    <span class="number">5305716</span>   <span class="number">44143584</span></span><br><span class="line">Swap:     <span class="number">33554424</span>   <span class="number">14794692</span>   <span class="number">18759732</span></span><br></pre></td></tr></table></figure></p><p>/proc/meminfo<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[~]$ cat <span class="meta-keyword">/proc/</span>meminfo</span><br><span class="line"><span class="symbol">MemTotal:</span>     <span class="number">49449300</span> kB</span><br><span class="line"><span class="symbol">MemFree:</span>      <span class="number">24631608</span> kB</span><br><span class="line"><span class="symbol">Buffers:</span>       <span class="number">3602140</span> kB</span><br><span class="line"><span class="symbol">Cached:</span>       <span class="number">15912388</span> kB</span><br><span class="line"><span class="symbol">SwapCached:</span>    <span class="number">2354868</span> kB</span><br><span class="line"><span class="symbol">Active:</span>       <span class="number">10286124</span> kB</span><br><span class="line"><span class="symbol">Inactive:</span>     <span class="number">13448900</span> kB</span><br><span class="line"><span class="symbol">HighTotal:</span>           <span class="number">0</span> kB</span><br><span class="line"><span class="symbol">HighFree:</span>            <span class="number">0</span> kB</span><br><span class="line"><span class="symbol">LowTotal:</span>     <span class="number">49449300</span> kB</span><br><span class="line"><span class="symbol">LowFree:</span>      <span class="number">24631608</span> kB</span><br><span class="line"><span class="symbol">SwapTotal:</span>    <span class="number">33554424</span> kB</span><br><span class="line"><span class="symbol">SwapFree:</span>     <span class="number">18759732</span> kB</span><br><span class="line"><span class="symbol">Dirty:</span>            <span class="number">1696</span> kB</span><br><span class="line"><span class="symbol">Writeback:</span>           <span class="number">0</span> kB</span><br><span class="line"><span class="symbol">AnonPages:</span>     <span class="number">1965432</span> kB</span><br><span class="line"><span class="symbol">Mapped:</span>          <span class="number">38332</span> kB</span><br><span class="line"><span class="symbol">Slab:</span>           <span class="number">890560</span> kB</span><br><span class="line"><span class="symbol">PageTables:</span>      <span class="number">84276</span> kB</span><br><span class="line"><span class="symbol">NFS_Unstable:</span>        <span class="number">0</span> kB</span><br><span class="line"><span class="symbol">Bounce:</span>              <span class="number">0</span> kB</span><br><span class="line"><span class="symbol">CommitLimit:</span>  <span class="number">58279072</span> kB</span><br><span class="line"><span class="symbol">Committed_AS:</span> <span class="number">20471392</span> kB</span><br><span class="line"><span class="symbol">VmallocTotal:</span> <span class="number">34359738367</span> kB</span><br><span class="line"><span class="symbol">VmallocUsed:</span>    <span class="number">279448</span> kB</span><br><span class="line"><span class="symbol">VmallocChunk:</span> <span class="number">34359458679</span> kB</span><br><span class="line"><span class="symbol">HugePages_Total:</span>     <span class="number">0</span></span><br><span class="line"><span class="symbol">HugePages_Free:</span>      <span class="number">0</span></span><br><span class="line"><span class="symbol">HugePages_Rsvd:</span>      <span class="number">0</span></span><br><span class="line"><span class="symbol">Hugepagesize:</span>     <span class="number">2048</span> kB</span><br></pre></td></tr></table></figure></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://linuxperf.com/?p=142" target="_blank" rel="noopener">/PROC/MEMINFO之谜</a></li><li><a href="https://javawind.net/p131" target="_blank" rel="noopener">linux top命令VIRT,RES,SHR,DATA的含义</a></li><li><a href="https://segmentfault.com/a/1190000008125006" target="_blank" rel="noopener">Linux内存管理</a></li><li><a href="https://www.cnblogs.com/lifexy/p/7651667.html" target="_blank" rel="noopener">22.Linux-块设备驱动之框架详细分析(详解)</a></li><li><a href="http://linuxperf.com/?p=143" target="_blank" rel="noopener">怎样统计所有进程总共占用多少内存？</a></li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Echarts-百度地图省分着色</title>
      <link href="/2018/05/03/Echarts-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E7%9C%81%E5%88%86%E7%9D%80%E8%89%B2/"/>
      <url>/2018/05/03/Echarts-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E7%9C%81%E5%88%86%E7%9D%80%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>通过Echarts3结合百度地图，对全国省分进行着色。<br><a id="more"></a></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于Echarts3中，不再使用china.js文件：</p><blockquote><p>ECharts 之前提供下载的矢量地图数据来自第三方，由于部分数据不符合国家《测绘法》规定，目前暂时停止下载服务。<br>建议大家使用以百度地图为底图的形式，参考实例：<a href="http://echarts.baidu.com/demo.html#map-polygon" target="_blank" rel="noopener">http://echarts.baidu.com/demo.html#map-polygon</a></p></blockquote><p>学习百度地图使用方法，先用各省分着色练手。</p><h2 id="百度地图-API"><a href="#百度地图-API" class="headerlink" title="百度地图 API"></a>百度地图 API</h2><p>可参考官方文档：</p><ul><li><a href="http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html#a3b14" target="_blank" rel="noopener">百度地图开放平台：JavaScript API v2.0类参考</a></li><li><a href="http://lbsyun.baidu.com/index.php?title=jspopular/guide/custom" target="_blank" rel="noopener">百度地图开放平台：JavaScript API</a></li></ul><h2 id="Echarts结合百度地图官方实例"><a href="#Echarts结合百度地图官方实例" class="headerlink" title="Echarts结合百度地图官方实例"></a>Echarts结合百度地图官方实例</h2><ul><li><a href="http://echarts.baidu.com/blog/2016/06/13/echarts-map-tutorial.html" target="_blank" rel="noopener">ECharts 实现地图散点图（下）</a></li><li><a href="http://echarts.baidu.com/demo.html#map-polygon" target="_blank" rel="noopener">http://echarts.baidu.com/demo.html#map-polygon</a></li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>在首页中引入bmap.js与百度地图的api</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/echarts/bmap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://api.map.baidu.com/api?v=2.0&amp;ak=您自己的ak"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>初始化echarts图表，并<code>setOption</code>百度地图的参数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bmapCharts = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'chinaProvMap'</span>));</span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  bmap: &#123;&#125; <span class="comment">// 此处为空，各类参数后面通过百度地图api进行设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取bmap并进行地图设置</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var map</span> = bmapCharts.getModel().getComponent(<span class="string">'bmap'</span>).getBMap();</span><br></pre></td></tr></table></figure></li></ol><h2 id="百度地图配置代码"><a href="#百度地图配置代码" class="headerlink" title="百度地图配置代码"></a>百度地图配置代码</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let provList = new <span class="symbol">Array</span>([<span class="string">"黑龙江"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"吉林省"</span>,<span class="string">"#01933F"</span>],[<span class="string">"辽宁"</span>,<span class="string">"#FAC300"</span>],[<span class="string">"内蒙古"</span>,<span class="string">"#FCF502"</span>],[<span class="string">"河北"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"北京"</span>,<span class="string">"#FCF502"</span>],[<span class="string">"天津"</span>,<span class="string">"#01933F"</span>],[<span class="string">"山东省"</span>,<span class="string">"#FCF502"</span>],[<span class="string">"江苏"</span>,<span class="string">"#D8EDDA"</span>],[<span class="string">"上海"</span>,<span class="string">"#B9B4C8"</span>],[<span class="string">"浙江"</span>,<span class="string">"#FCF502"</span>],[<span class="string">"福建"</span>,<span class="string">"#FAC300"</span>],[<span class="string">"台湾"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"广东"</span>,<span class="string">"#FCF502"</span>],[<span class="string">"香港"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"澳门"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"海南"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"广西"</span>,<span class="string">"#FAC300"</span>],[<span class="string">"云南"</span>,<span class="string">"#FCF502"</span>],[<span class="string">"西藏"</span>,<span class="string">"#B9B4C8"</span>],[<span class="string">"新疆"</span>,<span class="string">"#FAC300"</span>],[<span class="string">"甘肃"</span>,<span class="string">"#01933F"</span>],[<span class="string">"青海"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"四川"</span>,<span class="string">"#FAC300"</span>],[<span class="string">"贵州"</span>,<span class="string">"#01933F"</span>],[<span class="string">"重庆"</span>,<span class="string">"#B9B4C8"</span>],[<span class="string">"湖南"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"江西"</span>,<span class="string">"#01933F"</span>],[<span class="string">"湖北"</span>,<span class="string">"#FCF502"</span>],[<span class="string">"安徽"</span>,<span class="string">"#FAC300"</span>],[<span class="string">"河南"</span>,<span class="string">"#B9B4C8"</span>],[<span class="string">"陕西"</span>,<span class="string">"#F09ABD"</span>],[<span class="string">"山西"</span>,<span class="string">"#01933F"</span>],[<span class="string">"宁夏"</span>,<span class="string">"#FAC300"</span>]); //通过取色器获取各省颜色</span><br><span class="line"></span><br><span class="line">map.centerAndZoom(<span class="string">"兰州"</span>, <span class="number">5</span>); //取兰州作为中心点</span><br><span class="line"></span><br><span class="line">map.addControl(new <span class="symbol">BMap</span>.<span class="symbol">NavigationControl</span>()); // 缩放控件</span><br><span class="line">map.addControl(new <span class="symbol">BMap</span>.<span class="symbol">ScaleControl</span>()); // 比例尺</span><br><span class="line">map.enableScrollWheelZoom();</span><br><span class="line">function getBoundary(provItem)&#123;    </span><br><span class="line">  // console.log(provItem);   </span><br><span class="line">  var bdary = new <span class="symbol">BMap</span>.<span class="symbol">Boundary</span>();</span><br><span class="line">  bdary.get(provItem[<span class="number">0</span>], function(rs)&#123;       //获取行政区域</span><br><span class="line">    var count = rs.boundaries.length; //行政区域的点有多少个</span><br><span class="line">    if (count === <span class="number">0</span>) &#123;</span><br><span class="line">        alert(<span class="string">'未能获取当前输入行政区域'</span>);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    var pointArray = [];</span><br><span class="line">    for (var i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        let ply = new <span class="symbol">BMap</span>.<span class="symbol">Polygon</span>(rs.boundaries[i], &#123;strokeWeight: <span class="number">1</span>, strokeColor: <span class="string">"#aaaaaa"</span>, fillColor: provItem[<span class="number">1</span>]&#125;); //建立多边形覆盖物</span><br><span class="line">        map.addOverlay(ply);  //添加覆盖物</span><br><span class="line">        pointArray = pointArray.concat(ply.getPath());      </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  provList.forEach(function(item)&#123;</span><br><span class="line">    getBoundary(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://segmentfault.com/img/bV9UWN?w=1310&amp;h=551" alt="局部图"></p><p><img src="https://segmentfault.com/img/bV9UWQ?w=460&amp;h=443" alt="整体图"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/i-gps/archive/2012/07/17/2595733.html" target="_blank" rel="noopener">在百度地图或谷歌地图给中国各省着色并高亮显示</a></li><li><a href="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C19%2C1024%2C676%3Bc0%3Dbaike116%2C5%2C5%2C116%2C38/sign=9918cb82b1a1cd1111f928608422e4cd/b8389b504fc2d562e4f1ff5fec1190ef77c66c82.jpg" target="_blank" rel="noopener">百度百科-中国地图</a></li><li><a href="http://fatedgar.iteye.com/blog/2025972" target="_blank" rel="noopener">百度地图画多边形区域</a></li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> echarts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>svn学习手册-eclipse插件</title>
      <link href="/2018/04/27/svn%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C-eclipse%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/04/27/svn%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C-eclipse%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>在eclipse上安装svn插件，便于代码编辑后可以直接提交。目前主机上已安装TortoiseSVN。<br><a id="more"></a></p><h2 id="安装subclipse"><a href="#安装subclipse" class="headerlink" title="安装subclipse"></a>安装subclipse</h2><h3 id="分析对应版本"><a href="#分析对应版本" class="headerlink" title="分析对应版本"></a>分析对应版本</h3><p>首先查看本机TortoiseSVN的版本：本地TortoiseSVN的版本可以通过：右键-&gt;TortoiseSVN-&gt;about 查看</p><blockquote><p>TortoiseSVN 1.9.1, Build 26747 - 64 Bit</p></blockquote><p>如下是subclipse与tortoise两者之间的版本对应关系（不是subclipse与svn的对应关系）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Subclipse</span> 1<span class="selector-class">.10</span><span class="selector-class">.x</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">TortoiseSVN</span> 1<span class="selector-class">.8</span><span class="selector-class">.x</span></span><br><span class="line"><span class="selector-tag">Subclipse</span> 1<span class="selector-class">.8</span><span class="selector-class">.x</span>  <span class="selector-tag">--</span>&gt; <span class="selector-tag">TortoiseSVN</span> 1<span class="selector-class">.7</span><span class="selector-class">.x</span></span><br><span class="line"><span class="selector-tag">Subclipse</span> 1<span class="selector-class">.6</span><span class="selector-class">.x</span>  <span class="selector-tag">--</span>&gt; <span class="selector-tag">TortoiseSVN</span> 1<span class="selector-class">.6</span><span class="selector-class">.x</span></span><br><span class="line"><span class="selector-tag">Subclipse</span> 1<span class="selector-class">.4</span><span class="selector-class">.x</span>  <span class="selector-tag">--</span>&gt; <span class="selector-tag">TortoiseSVN</span> 1<span class="selector-class">.5</span><span class="selector-class">.x</span></span><br></pre></td></tr></table></figure></p><p>注意：subclipse官网已不再维护，转到了github上：   <code>https://github.com/subclipse/subclipse/wiki</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Subclipse</span> 4<span class="selector-class">.2</span><span class="selector-class">.X</span> 可以用于 <span class="selector-tag">TortoiseSVN</span> 1<span class="selector-class">.9</span><span class="selector-class">.X</span>版本</span><br></pre></td></tr></table></figure></p><h3 id="subclipse插件安装流程"><a href="#subclipse插件安装流程" class="headerlink" title="subclipse插件安装流程"></a>subclipse插件安装流程</h3><p>本次使用eclipse<strong>在线安装</strong>，在eclipse中执行通过：</p><ol><li>eclipse工具栏选择：help-&gt;Install New Software，点击右侧<code>Add</code>按钮；</li><li>在<code>Location</code>输入框中输入<code>https://dl.bintray.com/subclipse/releases/subclipse/4.2.x/</code>，不需要填Name，点击<code>ok</code>；</li><li>等待<code>Pending</code>页面显示<code>Core SVNkit Library</code>、<code>Subclipse</code>等选项时，点击<code>Select All</code>，点击取消最下面的<code>Contact all update sites during install……</code>选项，点击<code>Finish</code>；</li><li>若有弹窗，一直点击<code>next</code>直到完成</li><li>确认eclipse立即重启</li></ol><p>eclipse重启后，查看工具栏：Window-&gt;Preferences-&gt;Team-&gt;SVN 查看<code>svn接口</code>，使用SVNKIT能够正常使用svn，使用javaHL有异常……</p><h2 id="连接到svn版本库"><a href="#连接到svn版本库" class="headerlink" title="连接到svn版本库"></a>连接到svn版本库</h2><ol><li>右键点击工程：dailyMonitor-&gt;Team-&gt;Share project 选择<code>svn</code> 点击<code>next</code> 准备进行与svn库连接；</li><li>选择<code>创建新的资源库位置</code>，点击<code>next</code>；</li><li>url配置为：<code>svn://132.XX.XX.XX:6666/dailyMonitor</code>，点击<code>next</code>；</li><li>选择<code>使用项目名称作为文件夹名</code>，点击<code>finish</code>；</li><li>输入用户名、密码：用户名为xukf1 密码为fS123，点击<code>ok</code>；</li><li>若弹窗提示<code>已存在于资源库中……</code>，选择<code>yes</code>；</li><li>对于<code>Confirm Open Perspective</code>弹窗，选择<code>yes</code></li></ol><p>配置完成后，可以查看相关svn操作</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/yilylong/article/details/45970587" target="_blank" rel="noopener">TortoiseSVN 与SubEclipse 相互兼容版本对应</a></li><li><a href="https://www.cnblogs.com/reese-blogs/p/5557879.html" target="_blank" rel="noopener">Mac eclipse安装SVN +javaHL 安装使用详情</a></li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> FreshMan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>svn学习手册-服务器端离线安装</title>
      <link href="/2018/04/26/svn%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
      <url>/2018/04/26/svn%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>1.6版本的svn服务器端（Linux RedHat）离线安装流程，目前主机已经有：GCC、G++、openssl<br><a id="more"></a></p><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>对于1.6.X来说，离线安装包分为两个：svn与它的<code>deps</code>依赖包。依赖包里包括：<code>apr</code>、<code>apr-util</code>、<code>zlib</code>等。如果是没有提供deps依赖包的其他版本svn，可能需要自行下载对应<code>apr</code>、<code>apr-util</code>等。  </p><p>查找Apache Subversion官网，选择<code>Source Download</code>-&gt;<code>archive download site</code> 查找历史档案，找到自己待下载的安装包：<a href="https://archive.apache.org/dist/subversion/" target="_blank" rel="noopener">官网下载</a></p><ol><li>subversion-1.6.16.tar.bz2</li><li>subversion-deps-1.6.16.tar.bz2</li></ol><h2 id="解压、安装"><a href="#解压、安装" class="headerlink" title="解压、安装"></a>解压、安装</h2><ol><li>将两个安装包上传到服务器端<code>/xukf/svn</code>目录下</li><li><p>安装包解压，两个安装包会解压到一个文件内：<code>subversion-1.6.16</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-jxvf</span> <span class="selector-tag">subversion-1</span><span class="selector-class">.6</span><span class="selector-class">.16</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span></span><br><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-jxvf</span> <span class="selector-tag">subversion-deps-1</span><span class="selector-class">.6</span><span class="selector-class">.16</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span></span><br></pre></td></tr></table></figure></li><li><p>指定路径安装  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> subversion-1.6.16 <span class="comment"># 进入安装目录  </span></span><br><span class="line"><span class="string">./configure</span> <span class="params">--prefix=/xukf/svn</span> <span class="params">--without-berkeley-db</span> <span class="comment"># 安装到/xukf/svn目录下，不使用bdb数据库存储数据</span></span><br><span class="line">make  </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p> 安装时报bdb错误，可以忽略：</p><blockquote><p>configure: WARNING: we have configured without BDB filesystem support  </p></blockquote><p> 如果<code>configure</code>报未找到<code>apr</code>与<code>apr-util</code>，可以尝试使用<code>./configure --prefix=/settle/svn --with-apr=/settle/svn/subversion-1.6.16/apr/ --with-apr-util=/settle/svn/subversion-1.6.16/apr-util/</code></p></li><li>验证<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/xukf/svn/bin</span> <span class="comment"># 进入svn目录</span></span><br><span class="line"><span class="string">./svn</span> <span class="params">--version</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>svn，版本 1.6.16 (r1073529)<br>  编译于 Apr 26 2018，15:09:55<br>版权所有 (C) 2000-2009 CollabNet。  </p></blockquote><p>正确输出<code>svn</code>版本，表示svn安装成功。</p><h2 id="服务启停"><a href="#服务启停" class="headerlink" title="服务启停"></a>服务启停</h2><h3 id="版本库配置"><a href="#版本库配置" class="headerlink" title="版本库配置"></a>版本库配置</h3><ol><li><p>建立版本库目录：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /xukf/svn  </span><br><span class="line"><span class="built_in">mkdir</span> -p svndata/dailyMonitor</span><br></pre></td></tr></table></figure></li><li><p>创建版本库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/xukf/</span>svn<span class="regexp">/bin/</span>svnadmin create <span class="regexp">/xukf/</span>svn<span class="regexp">/svndata/</span>dailyMonitor</span><br></pre></td></tr></table></figure></li><li><p>修改参数文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cd /xukf/svn/svndata/dailyMonitor  </span><br><span class="line">cd conf  </span><br><span class="line">vim svnserve.conf  </span><br><span class="line">[general]  </span><br><span class="line">anon-access = none <span class="comment"># 非鉴权用户访问版本库的权限。取值范围为write、read和none，默认值为read  </span></span><br><span class="line">auth-access = write <span class="comment"># 鉴权用户访问版本库的权限。默认值为write  </span></span><br><span class="line">password-db = passwd <span class="comment"># 指定用户名口令文件名。除非指定绝对路径，否则文件位置为相对conf。默认值为passwd  </span></span><br><span class="line">authz-db = authz <span class="comment"># 指定权限配置文件名，通过该文件可以实现以路径为基础的访问控制  </span></span><br><span class="line">realm = jzjsMonitor <span class="comment"># 指定版本库的认证域，即在登录时提示的认证域名称  </span></span><br><span class="line">保存退出  </span><br><span class="line">vim passwd</span><br><span class="line">[users]</span><br><span class="line">xukf1 = fS123 <span class="comment"># 新增用户，注意左边不能有空格  </span></span><br><span class="line">xukf2 = Fs123  </span><br><span class="line">xukf3 = Fs123  </span><br><span class="line">保存退出  </span><br><span class="line">vim authz</span><br><span class="line">[groups]</span><br><span class="line">admin = xukf3 <span class="comment"># 分组管理权限</span></span><br><span class="line">weihu = xukf1,xukf2</span><br><span class="line"><span class="section">[dailyMonitor:/]</span></span><br><span class="line">@admin = rw <span class="comment"># 权限有""、"r"、"w"</span></span><br><span class="line">@weihu = rw  </span><br><span class="line">* = r  </span><br><span class="line">保存退出</span><br></pre></td></tr></table></figure></li></ol><h3 id="启停操作"><a href="#启停操作" class="headerlink" title="启停操作"></a>启停操作</h3><ol><li><p>启动svn服务</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/xukf/</span>svn<span class="meta-keyword">/bin/</span>svnserve -d -r <span class="meta-keyword">/xukf/</span>svn/svndata --listen-port <span class="number">6666</span>   </span><br><span class="line"><span class="meta"># -d：启动时运行在后台</span></span><br><span class="line"><span class="meta"># -r：将/xukf/svn/svndata作为根目录</span></span><br><span class="line"><span class="meta"># --listen-port：修改启动端口，默认为3690</span></span><br></pre></td></tr></table></figure><ul><li>访问路径为：<code>svn://132.XX.XX.XX:6666/dailyMonitor</code>  </li><li>注意启动路径，<code>/xukf/svn/svndata</code>时，url上需要带有<code>dailyMonitor</code>，如果直接用<code>/xukf/svn/svndata/dailyMonitor</code>，<code>/xukf/svn/svndata/dailyMonitor</code>为根目录，url上没有<code>dailyMonitor</code></li></ul></li><li><p>关闭svn服务<br>查找svn进程，直接杀死进程……</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/design321/article/details/9346513" target="_blank" rel="noopener">linux svn下载,安装和使用</a></li><li><a href="https://blog.csdn.net/thinkerabc/article/details/1831025" target="_blank" rel="noopener">svnserve配置文件详析</a></li><li><a href="http://www.51testing.com/html/71/410671-836310.html" target="_blank" rel="noopener">linux下subversion的安装</a></li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> FreshMan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>监控平台-概述</title>
      <link href="/2018/04/22/%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0-%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/04/22/%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0-%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>监控平台工程的概述，主要是对工程各层框架的描述；平台现已实现功能；并以一个功能为例讲述实现方式；钉钉微应用的相关知识；各层框架主要使用到的技术等。<br><a id="more"></a></p><h2 id="各层主要功能"><a href="#各层主要功能" class="headerlink" title="各层主要功能"></a>各层主要功能</h2><p>现在工程主要分为：前台、服务器端、数据整理脚本。</p><h3 id="1-前台"><a href="#1-前台" class="headerlink" title="1. 前台"></a>1. 前台</h3><p>用来进行用户交互与数据展示，前台包括PC端浏览器前台与钉钉微应用前台。  </p><ol><li>PC端前台</li></ol><p>包括1.0的界面与2.0界面。<br>1.0界面主要使用了<code>jQuery</code>库完成的前台渲染以及前后台交互。<br>2.0界面主要使用<code>React</code>对1.0界面进行了优化与新增功能开发。  </p><ol><li>钉钉微应用前台</li></ol><p>钉钉微应用前台还处于摸索开发阶段。<br>现阶段主要使用了React进行界面开发，部分功能涉及到调用钉钉API  </p><h3 id="2-服务器端"><a href="#2-服务器端" class="headerlink" title="2. 服务器端"></a>2. 服务器端</h3><p>服务器端主要完成了：对前台请求进行响应；调用短信网关发送告警短信；对文件读取方法进行封装；以及部分钉钉微应用服务器端调用方法的封装。</p><h3 id="3-数据整理脚本"><a href="#3-数据整理脚本" class="headerlink" title="3. 数据整理脚本"></a>3. 数据整理脚本</h3><p>数据整理脚本主要包括定时执行的监控脚本与相关信息的整理脚本。  </p><h2 id="已实现功能"><a href="#已实现功能" class="headerlink" title="已实现功能"></a>已实现功能</h2><ul><li>主机24小时CPU、内存、存储的使用情况监控</li><li>省间话单文件处理状态监控</li><li>2I2C、冰激凌等接口文件监控</li><li>省间文件级统计情况监控</li><li>短信告警</li><li>钉钉群自定义机器人发送消息</li><li>钉钉微应用试验性功能等</li></ul><h2 id="功能设计思路与实现流程"><a href="#功能设计思路与实现流程" class="headerlink" title="功能设计思路与实现流程"></a>功能设计思路与实现流程</h2><p>以国内漫游数据业务文件级统计结果检查功能为例：</p><p>设想一下，怎么做一个日统计结果查询到PC端浏览器前台展示的功能。</p><h3 id="一、分析手工进行的日统计结果正确性稽核方法"><a href="#一、分析手工进行的日统计结果正确性稽核方法" class="headerlink" title="一、分析手工进行的日统计结果正确性稽核方法"></a>一、分析手工进行的日统计结果正确性稽核方法</h3><p>通过比较统计中间表、统计日志表、file_info这三个表的各省话单量是否一致来判断。  </p><h3 id="二、对文件级统计监控功能点的总体流程梳理"><a href="#二、对文件级统计监控功能点的总体流程梳理" class="headerlink" title="二、对文件级统计监控功能点的总体流程梳理"></a>二、对文件级统计监控功能点的总体流程梳理</h3><ol><li>需要一个能够与用户交互的前台界面，用来给用户选择相应业务与待稽核时间，查看日文件级统计结果。</li><li>前台界面展示时，需要获取指定条件下的数据，这部分需要请求服务器端来进行数据查询并返回结果。</li><li>一般开发在前后端完成交互后基本功能就算完成了，考虑在实现日文件级统计监控时，如果多次查看该前台界面，会重复性的查询数据库这三个表，为了避免重复查询增加数据库负担，考虑编写脚本，每日只查询一次日统计结果，并将结果生成为落地日志文件，服务器端查询时，直接查询该日志文件。</li></ol><h3 id="三、相关流程详细设计"><a href="#三、相关流程详细设计" class="headerlink" title="三、相关流程详细设计"></a>三、相关流程详细设计</h3><ol><li>前台界面设计：<br>现在界面实现有两种方式：1.0采用<code>jQuery</code>，具体实现方案可查<code>js</code>目录下的<code>fskb.js</code>中<code>fileStat</code>相关函数；2.0采用<code>React</code>，具体实现方案可查<code>js/template</code>目录下的<code>HostFileStat.jsx</code>文件。总体设计思路如下：  <ol><li>进行页面布局设计，包括与用户交互设计、样例数据展示等；<br>1.0界面入口为<code>index.html</code>，新增监控功能导航需要修改该文件，并在<code>fskb.js</code>中完成相关函数编写；<br>2.0界面入口为<code>reactIndex.jsx</code>，新增监控功能导航需要修改该文件，并创建对应的<code>HostFileStat.jsx</code>文件，在<code>.jsx</code>文件中编写相关函数；</li><li>向服务器端发起请求与结果获取；使用Ajax向<code>FileStat_queryFileStat.action</code>发送<code>post</code>请求；</li><li>实际数据展示；通过Ajax获取到数据后，根据<code>jQuery</code>或者<code>React</code>框架来完成数据的展示。</li></ol></li><li>服务器端响应请求设计：<ol><li>对前台发起的请求进行响应；这部分通过<code>struts</code>框架来实现，创建<code>FileStatAction.java</code>文件，编写<code>queryFileStat</code>方法来响应前台<code>Ajax</code>发起的请求；</li><li>进行数据查询；根据面向接口编程，先创建java接口文件<code>FileStatDao.java</code>定义查询方法，再创建实现类<code>FileStatDaoImpl.java</code>,实现具体查询方法；</li><li>将查询结果返回至客户端前台；这部分依旧由<code>struts</code>来完成，在<code>FileStatAction.java</code>中将结果封装成json类型数据返回至前台。</li></ol></li><li>后台数据查询、整理脚本设计：<br>脚本连接49.151库查询国内漫游数据业务的统计中间表、统计日志表、file_info日话单量，并将查询结果形成落地日志文件。<ol><li>创建<code>statStatusCheck.py</code>脚本，定义获取各表数据的方法，例如<code>getStatLogInfo()</code>等；</li><li>创建<code>*.sql</code>文件，编写数据库查询语句，例如查询统计中间表的<code>gprsr_stat_final.sql</code>文件（所有的sql文件都在<code>sqlList</code>目录下）；</li><li>使用<code>sqlplus</code>连接数据库执行sql文件进行查询；</li><li>将查询结果写入到日志文件<code>gprsr_fileStat_YYYYMMDD.log</code>（存放在<code>fileStatInfo</code>目录下）；</li><li>将该脚本使用<code>crontab</code>定时，在每日定时执行一次，完成昨日文件级统计结果的查询。</li></ol></li></ol><h2 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h2><p>钉钉开发包括钉钉群机器人与钉钉微应用</p><h3 id="钉钉群自定义机器人"><a href="#钉钉群自定义机器人" class="headerlink" title="钉钉群自定义机器人"></a>钉钉群自定义机器人</h3><p>自定义机器人主要是通过调用钉钉API完成待发送信息发送至指定钉钉群。以出账进度钉钉群通知为例，进行流程分析：</p><ol><li>编写出账进度统计脚本<code>billMonitor.py</code>，主要实现对各业务的出账进度统计；</li><li>编写发送内容到钉钉群的脚本<code>billMonitorClient.py</code>，主要实现了将信息格式化成json串并通过钉钉API调用自定义机器人发送至钉钉群</li><li>由于没有外网主机，49.206不能直接与钉钉通信，所以编写了用于主机通信的服务器端<code>transitServer.py</code>与客户端<code>socketClient.py</code></li></ol><p>另外，通过分析钉钉自定义机器人API，形成了钉钉群自定义机器人工具类方法封装<code>dingTalkRobot.py</code></p><h3 id="钉钉微应用"><a href="#钉钉微应用" class="headerlink" title="钉钉微应用"></a>钉钉微应用</h3><p>在复用监控平台后台代码与数据的基础上，进行的移动端开发。主要使用antd-mobile UI库来进行移动端布局。</p><h2 id="短信服务"><a href="#短信服务" class="headerlink" title="短信服务"></a>短信服务</h2><p>通过调用短信网关发送自定义短信。<br>告警发送短信流程可以参考：<a href="http://localhost:8080" target="_blank" rel="noopener">国内漫游业务Redis短信告警监控实现</a></p><h2 id="工程各文件-目录含义"><a href="#工程各文件-目录含义" class="headerlink" title="工程各文件/目录含义"></a>工程各文件/目录含义</h2><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><ul><li><code>js</code>目录：包含全局<code>*js</code>文件、<code>webpack</code>参数、以及编译入口的<code>*jsx</code>文件等</li><li><code>js/template</code>目录：包含各功能的<code>.jsx</code>文件</li><li><code>js/node_modules</code>目录：包含<code>webpack</code>相关库、挂载组件库等。该目录不需要特别关心</li><li><code>util</code>目录：工具类，包含日期选择插件、等待进度条等</li><li><code>hostShell</code>目录：客户端/服务器端脚本，例如：出账进度统计、socket通信等脚本</li><li><code>css</code>、<code>html</code>、<code>fonts</code>、<code>img</code>目录：前台相关样式、图片等</li><li><code>webcontent</code>目录下<code>*.py</code>文件、<code>*Info</code>目录、<code>*_info</code>文件、<code>*.txt</code>文件、<code>*Date</code>文件、<code>*Doc</code>等与49.206主机<code>/settle/settle/bin/xukf/autoMonitor/hostMonitor</code>目录下文件一一对应，具体含义在主机详述。在进行监控点调试时，从49.206主机上对应目录下获取日志文件。</li><li>其他目录使用频率极低</li></ul><h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><ul><li><code>*Info</code>目录：各监控点的监控结果日志文件</li><li><code>*_info</code>文件：各监控点的参数文件，类似于数据库的参数表</li><li><code>*.txt</code>文件：主机监控、进程监控的标识位文件，基本不用关注</li><li><code>*Date</code>目录：主机监控结果汇总日志文件</li><li><code>*Doc</code>目录：主机监控结果单独日志文件</li><li><code>*.py</code>、<code>*.sh</code>文件：监控脚本</li><li><code>log_*</code>文件：定时执行脚本时生成的日志文件</li></ul><h2 id="各架构具体技术"><a href="#各架构具体技术" class="headerlink" title="各架构具体技术"></a>各架构具体技术</h2><h3 id="前台-1"><a href="#前台-1" class="headerlink" title="前台"></a>前台</h3><ul><li>使用<code>bootstrap</code>、<code>antd</code>等UI框架，配合自定义的<code>HTML</code>、<code>CSS</code>进行界面展示</li><li>使用<code>Ajax</code>进行前后台数据交互（同步/异步）</li><li>使用<code>jQuery</code>或者<code>React</code>框架进行整合完成与用户的交互</li><li>使用<code>React</code>时，使用部分ES6语法，通过<code>webpack</code>后台打包方式完成JSX ES6语法转化</li><li>对于钉钉微应用，通过js调用钉钉API进行微应用鉴权、获取用户信息等。</li></ul><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ul><li>主要分为Action层，dao层、dao实现层、pojo以及util工具类</li><li>使用JavaEE的<code>struts</code>框架作为控制器完成对前后台数据的交互。</li><li>使用<code>ojdbc</code>连接Oracle库进行增删改查。</li><li>使用<code>Tomcat</code>作为服务器容器。</li></ul><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul><li>python、bash shell选择使用，建议使用python</li><li>python使用sqlplus或者cx_oracle连接数据库，建议使用cx_oracle</li><li>使用crontab进行监控脚本定时</li></ul><h3 id="钉钉-1"><a href="#钉钉-1" class="headerlink" title="钉钉"></a>钉钉</h3><ul><li>使用python的socket暴露主机端口进行客户端与服务器端通信</li><li>使用钉钉自定义机器人自动发送钉钉群信息，具体方法有封装好的函数</li><li>使用钉钉API相关接口（包括jsapi与服务器端api）进行钉钉微应用的开发。</li></ul><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Echarts-tooltip</title>
      <link href="/2018/04/08/Echarts-tooltip/"/>
      <url>/2018/04/08/Echarts-tooltip/</url>
      <content type="html"><![CDATA[<p>用Echarts绘制的折线图中，鼠标悬浮到图上时给出的提示信息（由tooltip提示框组件提供）不满足要求，需要进行自定义化。<br><a id="more"></a></p><h2 id="tooltip-API"><a href="#tooltip-API" class="headerlink" title="tooltip API"></a>tooltip API</h2><p>可参考官方文档<a href="http://echarts.baidu.com/option3.html#tooltip" target="_blank" rel="noopener">tooltip</a>，本次是在<code>version: &#39;3.6.2&#39;</code>版本下进行的自定义内容设置。</p><h2 id="可自定义位置"><a href="#可自定义位置" class="headerlink" title="可自定义位置"></a>可自定义位置</h2><ul><li>全局，即在option中的<code>tooltip</code></li><li>坐标系中，即<code>grid.tooltip</code>、<code>polar.tooltip</code>、<code>single.tooltip</code></li><li>系列中，即<code>series.tooltip</code></li><li>系列里的每个数据项中，即<code>series.data.tooltip</code></li></ul><p>为满足<strong>坐标轴触发</strong>展示自定义内容的需求，本文暂时讨论全局<code>tooltip</code>与系列中<code>tooltip</code>，以及自定义<code>formatter</code>。</p><h2 id="默认tooltip"><a href="#默认tooltip" class="headerlink" title="默认tooltip"></a>默认tooltip</h2><p>最基本的配置为：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tooltip</span> : &#123;</span><br><span class="line">    <span class="attribute">trigger</span>: <span class="string">'axis'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>鼠标悬浮到图上时，展示内容为：横坐标（name）、当前位置data值（value）、当前系列名称（seriesName）</p><h2 id="全局tooltip"><a href="#全局tooltip" class="headerlink" title="全局tooltip"></a>全局tooltip</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    tooltip : &#123;</span><br><span class="line">        trigger: <span class="string">'axis'</span>,</span><br><span class="line">        formatter: function(<span class="keyword">params</span>, ticket, callback)&#123;</span><br><span class="line">          <span class="keyword">var</span> recordCntArr = seriesContentArr[<span class="keyword">params</span>[<span class="number">0</span>].seriesIndex];</span><br><span class="line">          <span class="keyword">var</span> formatTxt = <span class="keyword">params</span>[<span class="number">0</span>].name + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">          formatTxt += <span class="string">'&lt;span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:'</span> + <span class="keyword">params</span>[<span class="number">0</span>].color + <span class="string">'"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">          formatTxt += <span class="string">"记录数："</span>+(<span class="keyword">params</span>[<span class="number">0</span>].<span class="keyword">value</span>+<span class="string">""</span>).replace(<span class="keyword">new</span> RegExp(<span class="string">'(\\d)(?=(\\d&#123;3&#125;)+$)'</span>,<span class="string">'ig'</span>),<span class="string">"$1,"</span>) + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">params</span>[<span class="number">0</span>].dataIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> formatTxt;</span><br><span class="line">          &#125;</span><br><span class="line">          formatTxt += <span class="string">"增长量："</span>+(recordCntArr[<span class="number">2</span>][<span class="keyword">params</span>[<span class="number">0</span>].dataIndex]+<span class="string">""</span>).replace(<span class="keyword">new</span> RegExp(<span class="string">'(\\d)(?=(\\d&#123;3&#125;)+$)'</span>,<span class="string">'ig'</span>),<span class="string">"$1,"</span>)+<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">          formatTxt += <span class="string">"增长率："</span>+recordCntArr[<span class="number">3</span>][<span class="keyword">params</span>[<span class="number">0</span>].dataIndex]+<span class="string">"%&lt;br /&gt;"</span>;</span><br><span class="line">          <span class="keyword">return</span> formatTxt;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过重写回调函数<code>formatter</code>的返回值来自定义提示信息。<code>&lt;span&gt;...&lt;/span&gt;</code>内为提示的小圆点。  </p><p>其中触发器<code>trigger</code>触发类型有三种：</p><ol><li><code>item</code>：数据项触发，对于折线图，是折线上的数据点</li><li><code>axis</code>：坐标轴触发，在折线图上，鼠标移动到数据点所在的坐标轴上便能触发</li><li><code>none</code>：不触发</li></ol><p>当<code>trigger</code>为<code>axis</code>时，<code>fomatter</code>中<code>params</code>为数组，为<code>item</code>时，<code>params</code>为对象。  </p><h2 id="系列中tooltip"><a href="#系列中tooltip" class="headerlink" title="系列中tooltip"></a>系列中tooltip</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">series : [</span><br><span class="line">    &#123;</span><br><span class="line">        name:<span class="string">'注册用户数'</span>,</span><br><span class="line">        type:<span class="string">'line'</span>,</span><br><span class="line">        data:userArr,</span><br><span class="line">        tooltip : &#123;</span><br><span class="line">          trigger: <span class="string">'item'</span>,</span><br><span class="line">          formatter: function(<span class="keyword">params</span>, ticket, callback)&#123;</span><br><span class="line">            console.log(<span class="keyword">params</span>);</span><br><span class="line">            <span class="keyword">var</span> formatTxt = <span class="keyword">params</span>.name + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">            formatTxt += <span class="string">'&lt;span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:'</span> + <span class="keyword">params</span>.color + <span class="string">'"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">            formatTxt += <span class="string">"记录数："</span>+(<span class="keyword">params</span>.<span class="keyword">value</span>+<span class="string">""</span>).replace(<span class="keyword">new</span> RegExp(<span class="string">'(\\d)(?=(\\d&#123;3&#125;)+$)'</span>,<span class="string">'ig'</span>),<span class="string">"$1,"</span>) + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">            formatTxt += <span class="string">"增长量："</span>+(userGrowthArr[<span class="keyword">params</span>.dataIndex]+<span class="string">""</span>).replace(<span class="keyword">new</span> RegExp(<span class="string">'(\\d)(?=(\\d&#123;3&#125;)+$)'</span>,<span class="string">'ig'</span>),<span class="string">"$1,"</span>)+<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">            formatTxt += <span class="string">"增长率："</span>+userRateArr[<span class="keyword">params</span>.dataIndex]+<span class="string">"%&lt;br /&gt;"</span>;</span><br><span class="line">            <span class="keyword">return</span> formatTxt;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>系列中tooltip可分别定义各系列特定的样式，在回调函数<code>fomatter</code>中自定义样式并返回。系列中<code>tooltip</code>优先级要高于全局<code>tooltip</code>  </p><p>需要注意的是：<strong>series.tooltip仅在<code>trigger</code>为<code>item</code>时有效</strong></p><blockquote><p>注意：series.tooltip 仅在 tooltip.trigger 为 ‘item’ 时有效</p></blockquote><p>所以使用系列中<code>tooltip</code>时，只能当鼠标悬浮到数据点上时才有提示。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="http://echarts.baidu.com/option3.html#tooltip" target="_blank" rel="noopener">tooltip</a></li><li><a href="https://www.jianshu.com/p/aa585c304660" target="_blank" rel="noopener">在echarts中自定义提示框内容</a></li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> echarts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记-生命周期</title>
      <link href="/2018/04/07/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/04/07/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>我要在何时给界面一个初始值；当内容变化时，我该在哪里控制界面重新渲染；为啥我的界面陷入了死循环……<br><a id="more"></a></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://segmentfault.com/img/remote/1460000011694930?w=761&amp;h=690" alt="React流程状态图"></p><p>这个流程图主要说明了按<code>createClass</code>的方式创建的React组件的生命周期，现在React推荐使用<code>Component</code>的方式创建组件，<code>createClass</code>与<code>Component</code>方式的不同主要为：</p><ol><li><code>createClass</code>为ES5的写法，<code>Component</code>为使用ES6语法</li><li><code>createClass</code>构造的组件中，各方法会自动绑定<code>this</code>。使用<code>Component</code>需要手动绑定<code>this</code>，例如在<code>constructor</code>构造器中绑定<code>this.getBaseInfo = this.getBaseInfo.bind(this);</code>或者在使用时绑定<code>onChange={this.categoryListChange.bind(this, &quot;CPU&quot;)}</code>，也可以使用箭头函数（arrow function）（匿名函数）<code>onChange={(&#39;CPU&#39;)=&gt;this.categoryListChange()</code>，使用箭头函数的方法不太提倡。</li><li>构造方法不同</li><li>对传入的<code>props</code>的默认值与配置不同<br>深入了解可见参考文章1</li></ol><h3 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h3><ul><li>constructor</li><li>componentWillMount</li><li>render</li><li>componentDidMount</li></ul><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>并不是每个React组件都需要构造方法<code>constructor</code>，一般在有<code>state</code>与绑定<code>this</code>的需求的时候才使用<code>constructor</code>。<br>在该阶段主要完成的是：</p><ol><li>初始化<code>state</code>值</li><li>完成函数的<code>this</code>绑定</li></ol><h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h4><p>组件在加载之前调用的方法，一般此方法的功能都可以在<code>constructor</code>中完成，为了<code>constructor</code>的简洁，比较常用此方法与<code>constructor</code>配合使用。<code>componentWillMount</code>执行完之后会立即执行<code>render</code>方法。<br>在该阶段主要能够进行：</p><ol><li>调用只与后台请求一次的方法，进行<code>state</code>初始化。若使用非异步方法获取数据，会等到此阶段执行完成才调用<code>render</code>方法；</li></ol><h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p>必需函数，完成<code>state</code>的更新与<code>DOM</code>渲染、更新。</p><h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p>在组件装载完成后调用。需要注意的是，若有父子组件调用的情况，只有当所有子组件都完成<code>render</code>后，才依次调用各子组件与父组件的<code>componentDidMount</code>方法。<br>该阶段主要能够进行：</p><ol><li>与后台交互获取数据，可以避免界面渲染的等待时间；</li></ol><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><ul><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li></ul><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>在父子组件的情况下，当父组件进行<code>render</code>时，子组件的该方法就会执行。在该方法中，可以根据原<code>props</code>的值与<code>nextProps</code>的值来决定是否进行组件的<code>state</code>更新。<br>该阶段主要能够进行：</p><ol><li>根据<code>nextProps</code>更新组件的<code>state</code>；</li></ol><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>判断本组件本次是否需要渲染。默认返回值为<code>true</code>。可以通过<code>nextProps</code>、<code>nextState</code>与<code>props</code>、<code>state</code>来决定本次是否需要渲染DOM对象。在渲染DOM比较耗时或者是更新陷入死循环的情况下，可考虑通过此方法避免无意义渲染，进行性能调优。</p><h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h4><p>当<code>shouldComponentUpdate</code>返回结果为<code>true</code>时会执行此方法，需要注意的是，要避免在此方法内调用<code>setState</code>方法，否则会陷入<code>state</code>修改-&gt;渲染-&gt;<code>state</code>修改-&gt;渲染这样的死循环中。</p><h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>当更新过程执行完<code>render</code>后被调用，在此周期中可以使用<code>setState</code>，但要注意使用时也会引起更新过程，所以需要在<code>setState</code>之前限制条件，或者在<code>shouldComponentUpdate</code>中进行条件限制已避免陷入死循环。</p><h3 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h3><ul><li>componentWillUnmount</li></ul><h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p>在组件卸载时被调用，在此过程中可以清理掉由<code>componentDidMount</code>方法中通过非React方法创建的DOM元素，以避免内存泄露。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/wonyun/p/5930333.html" target="_blank" rel="noopener">React创建组件的三种方式及其区别</a></li><li><a href="https://segmentfault.com/a/1190000011694925" target="_blank" rel="noopener">了解React组件生命周期</a></li><li><a href="http://react-china.org/t/react/1740" target="_blank" rel="noopener">React组件生命周期过程说明</a></li><li><a href="https://segmentfault.com/a/1190000006792687" target="_blank" rel="noopener">React组件生命周期</a></li><li><a href="https://segmentfault.com/q/1010000008133309" target="_blank" rel="noopener">React数据获取为什么一定要在componentDidMount里面调用？</a></li><li>深入浅出React和Redux</li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> FreshMan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记-React是什么</title>
      <link href="/2018/04/05/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-React%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/04/05/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-React%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>这一章主要思考了选择React进行项目现有功能重构的原因，<strong>自己</strong>jQuery项目中遇到的使自己感到处理很复杂的问题，如果用react会不会简单；jQuery与react的区别是什么？JSX？虚拟DOM？生命周期？ES6？<br><a id="more"></a></p><h2 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h2><p>React是使用JSX语法扩展方式，通过虚拟DOM（Virtual DOM）进行渲染的js库。其他具体说明可以看<a href="https://reactjs.org/blog/2013/06/05/why-react.html" target="_blank" rel="noopener">Why did we build React?</a></p><h2 id="Why-not-jQuery"><a href="#Why-not-jQuery" class="headerlink" title="Why not jQuery"></a>Why not jQuery</h2><p>这是在思考是否选择其他框架时一直在想的问题，即使现在选择了React，也依然在反思这个问题。</p><h3 id="jQuery工作方式"><a href="#jQuery工作方式" class="headerlink" title="jQuery工作方式"></a>jQuery工作方式</h3><p>先从jQuery工作方式入手思考。常用的jQuery进行前台渲染的流程主要是：</p><ol><li><p>产生一个HTML</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">role</span>=<span class="string">'presentation'</span> <span class="attr">class</span>=<span class="string">'fs-article-bar active'</span> <span class="attr">id</span>=<span class="string">"hostLiOverview"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'#'</span> <span class="attr">id</span>=<span class="string">"hostOverview"</span> <span class="attr">role</span>=<span class="string">'button'</span>&gt;</span>概览<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>绑定事件处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hostOverviewShow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'#hostOverview'</span>).unbind(<span class="string">'click'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>($(<span class="string">'#hostLiOverview'</span>).hasClass(<span class="string">'disabled'</span>))&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">'li[id*="hostLi"]'</span>).removeClass(<span class="string">"disabled"</span>);</span><br><span class="line">    $(<span class="string">'li[id="hostLiOverview"]'</span>).addClass(<span class="string">"disabled"</span>);</span><br><span class="line">    $(<span class="string">'#hostInfoShow'</span>).empty();</span><br><span class="line">    queryHostInfo();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可见jQuery的工作方式为：通过CSS规则找到对应id（或者class等）的DOM元素，将事件绑定到该元素上，读取元素内容或根据业务逻辑，对相应DOM元素进行修改。</p><h3 id="不足呢？"><a href="#不足呢？" class="headerlink" title="不足呢？"></a>不足呢？</h3><p>审视一下项目现有的jQuery代码，以上面代码为例，由于使用jQuery需要直接操作DOM元素，当<code>#hostOverview</code>元素点击时，需要对<code>li[id*=&quot;hostLi&quot;]</code>、<code>li[id=&quot;hostLiOverview&quot;]</code>、<code>#hostInfoShow</code>这三个DOM元素进行修改。如果关联的元素再增加，需要再修改<code>hostOverviewShow</code>方法。<br>通过这种事件处理与DOM修改的方式进行界面渲染，会导致程序结构变得复杂。也许可以通过重构来审视代码，进行结构调优，但对于尚未开发完的项目，必须想出良好的代码结构，在增加新功能的时候还需要特别注意是否影响代码的重构。保持良好的结构，很艰难……</p><h2 id="React程序流程"><a href="#React程序流程" class="headerlink" title="React程序流程"></a>React程序流程</h2><p>React对于事件处理到DOM修改的流程为：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[事件<span class="number">1</span>,事件<span class="number">2</span>,...,事件<span class="function"><span class="title">n</span>] -&gt;</span> <span class="function"><span class="title">render</span> -&gt;</span> V<span class="function"><span class="title">irtual</span> DOM -&gt;</span> DOM</span><br></pre></td></tr></table></figure></p><p>不需要开发者关注某一事件触发后具体修改哪些DOM，修改会由React的<code>render</code>过程来分析比对虚拟DOM并修改真实DOM。</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX是JavaScript的语法扩展。一个明显的特点是可以直接使用HTML的元素，当然，并不局限于HTML元素，也可以是任何一个React的组件。</p><h3 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h3><p>一个简单的JSX如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WelcomeHostMonitor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;<span class="type">Hello</span> ~&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="type">WelcomeHostMonitor</span></span><br></pre></td></tr></table></figure></p><p>在JSX中，可以直接使用<code>onClick</code>的方式给一个元素绑定事件处理函数，例如：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">topBarSelect(opType)&#123;</span><br><span class="line">  console.log(<span class="string">"Now opType is:"</span>+opType);</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hello ~&lt;/h1&gt;</span><br><span class="line">      &lt;<span class="keyword">div</span> onClick=&#123;<span class="keyword">this</span>.topBarSelect.bind(<span class="keyword">this</span>, <span class="string">"HostProvFile"</span>)&#125;&gt;文件监控&lt;/a&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对元素增加onClick是否合理"><a href="#对元素增加onClick是否合理" class="headerlink" title="* 对元素增加onClick是否合理"></a>* 对元素增加onClick是否合理</h3><p>在学习jQuery的时候，一直避免在HTML元素上直接绑定<code>onclick</code>方法，HTML绑定<code>onclick</code>方法问题有很多，像：不方便管理、在删除DON的时候使用<code>removeEventListener</code>注销相关事件处理器等。但React的<code>onClick</code>不同于在HTML上的<code>onclick</code>，<del>因为它的C是大写的</del>，因为它只存在于组件的生命周期内，每个组件的<code>onClick</code>都会在组件卸载（unmount）时清除。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟DOM（Virtual DOM）可以看做是对DOM的抽象，当React进行重复渲染来进行DON修改完成用户交互时，并不需要需改组件的全部DOM，它会比对本次的虚拟DOM与上次的虚拟DOM，找出真正需要修改的DOM点进行修改。这种渲染最少DOM方式的效率在当前项目中不需要担心。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>React中最需要学习的点，React在渲染的过程中，会按照流程调用各生命周期函数，所以一些逻辑处理可以在各生命周期函数中进行，生命周期的大体流程可见<a href="https://segmentfault.com/a/1190000011694925" target="_blank" rel="noopener">了解React组件生命周期</a></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>使用ES6来写React能带来不少便捷，例如使用箭头函数会自动绑定this等（不知道该不该推荐这样使用），但当前部分浏览器并不支持ES6,所以需要转义成ES5，转义方式以后再分析，当然，ES6不是必需的，也可以直接使用ES5语言来编写，但强烈建议学习或者了解一下ES6。ES6语法的学习可以见参考文章的ECMAScript 6 入门。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cnblogs.com/libin-1/p/6013490.html" target="_blank" rel="noopener">JavaScript常见的内存泄漏原因</a></li><li><a href="https://www.cnblogs.com/polk6/p/5097334.html" target="_blank" rel="noopener">HTML 事件(二) 事件的注册与注销</a></li><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li><li>深入浅出React和Redux</li></ol><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> FreshMan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React学习笔记-索引</title>
      <link href="/2018/04/04/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/04/04/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>用react有一段时间（&lt;= 3Months），主要用到了react的生命周期、父子组件通信、与其他组件结合使用等等。这一章为笔记索引。<br><a id="more"></a></p><h2 id="1、react是什么，为什么要替换jQuery"><a href="#1、react是什么，为什么要替换jQuery" class="headerlink" title="1、react是什么，为什么要替换jQuery"></a>1、react是什么，为什么要替换jQuery</h2><p>思考了一下<strong>自己</strong>jQuery项目中遇到的使自己感到处理很复杂的问题，如果用react会不会简单；jQuery与react的区别是什么？JSX？虚拟DOM？生命周期？ES6？。</p><h2 id="2、react最主要的生命周期"><a href="#2、react最主要的生命周期" class="headerlink" title="2、react最主要的生命周期"></a>2、react最主要的生命周期</h2><p>我要在何时给界面一个初始值；当内容变化时，我该在哪里控制界面重新渲染；为啥我的界面陷入了死循环……</p><h2 id="3、react父子组件如何通信"><a href="#3、react父子组件如何通信" class="headerlink" title="3、react父子组件如何通信"></a>3、react父子组件如何通信</h2><p>能接收父组件的传参吗？子组件想要给父组件返回值呢？</p><h2 id="4、react-ES6-babel转义"><a href="#4、react-ES6-babel转义" class="headerlink" title="4、react ES6 babel转义"></a>4、react ES6 babel转义</h2><p>啊哦，浏览器不支持ES6；咦，为什么我的前台界面渲染这么慢（前端解析ES6能不慢么）</p><h2 id="5、react-jQuery-jQuery组件应用等"><a href="#5、react-jQuery-jQuery组件应用等" class="headerlink" title="5、react+jQuery jQuery组件应用等"></a>5、react+jQuery jQuery组件应用等</h2><p>好纠结，原项目用jQuery封装好的方法类要不要重新写？不写的话我该怎么用？</p><h2 id="6、react-Ajax-后台交互，绑定变量等"><a href="#6、react-Ajax-后台交互，绑定变量等" class="headerlink" title="6、react+Ajax 后台交互，绑定变量等"></a>6、react+Ajax 后台交互，绑定变量等</h2><p>我想要找后台讨论一下当前条件下的查询结果，我该咋办？震惊！你还在用Ajax？</p><h2 id="7、react-Echarts-数据渲染等"><a href="#7、react-Echarts-数据渲染等" class="headerlink" title="7、react+Echarts 数据渲染等"></a>7、react+Echarts 数据渲染等</h2><p>“看别人的统计界面，折线图、柱状图、饼图各种直观化图形界面，看看你的，一堆数字表格，退回重做！”</p><h2 id="8、react-Antd-前台样式库"><a href="#8、react-Antd-前台样式库" class="headerlink" title="8、react+Antd 前台样式库"></a>8、react+Antd 前台样式库</h2><p>当你作为一个伪全栈，费劲所剩不多的脑子去搞前台样式时，不妨试一下Antd，即使样式不满足需求，至少可以提供思路。</p><h2 id="8、react-redux"><a href="#8、react-redux" class="headerlink" title="8、react+redux"></a>8、react+redux</h2><p>如何保证数据一致性？Flux is what？redux2333，</p><hr><p><a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="noopener" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。</p>]]></content>
      
      <categories>
          
          <category> FreshMan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle 数据库服务停启</title>
      <link href="/2018/02/23/Oracle-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%81%9C%E5%90%AF/"/>
      <url>/2018/02/23/Oracle-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%81%9C%E5%90%AF/</url>
      <content type="html"><![CDATA[<p>数据库服务宕掉该如何重启<br><a id="more"></a></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="查看数据库状态"><a href="#查看数据库状态" class="headerlink" title="查看数据库状态"></a>查看数据库状态</h4><pre><code>sqlplus / as sysdbaSELECT status FROM V$INSTANCE;</code></pre><p>查询报：<code>ORA-01034</code>则表示数据库服务未启动</p><h4 id="数据库服务关闭"><a href="#数据库服务关闭" class="headerlink" title="数据库服务关闭"></a>数据库服务关闭</h4><ol><li>SHUTDOWN IMMEDIATE<br>会中断正在执行的SQL语句，并将未提交的事务进行回滚，断开所有连接的用户</li><li>SHUTDOWN NORMAL<br>不允许新建连接，等待现有连接用户全部退出之后才关闭数据库。下次启动不需要进行任何实例恢复。</li><li><p>SHUTDOWN ABORT<br>类似于强制关闭，会中断正在执行的SQL语句，且不回滚未提交的事务。下次启动时需要进行实例恢复，启动时可能耗时较长。一般在如下场景使用该命令：  </p><ol><li>数据库处于一种非正常工作状态，不能用shutdown normal或者shutdown immediate这样的命令关闭数据库;</li><li>需要立即关闭数据库；</li><li>在启动数据库实例时遇到问题；</li></ol></li></ol><p>有关于checkPoint的知识点尚未接触，暂无。</p><h4 id="数据库服务启动"><a href="#数据库服务启动" class="headerlink" title="数据库服务启动"></a>数据库服务启动</h4><ol><li>STARTUP NOMOUNT<br>仅创建一个oracle实例，读取init.ora初始化参数文件、启动后台进程、初始化系统全局区（SGA）。需要继续执行以下命令才能打开数据库：<pre><code>ALTER DATABASE MOUNT;ALTER DATABASE OPEN;</code></pre></li><li>STARTUP MOUNT<br>创建实例并且挂载数据库，但没有打开数据库。 需要继续执行以下命令才能打开数据库：<pre><code>ALTER DATABASE OPEN;</code></pre></li><li>STARTUP<br>该命令包含：创建实例、挂载实例、打开数据库的所有步骤。成功结束后数据库系统便处于正常工作状态，可以接受用户请求。<br><img src="https://github.com/francisXKF/francisXKF.github.io/tree/master/images/orcle-startup.png" alt="STARTUP启动成功"></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/guohu/p/4253418.html" target="_blank" rel="noopener">Oracle数据库实例的启动及关闭</a></p>]]></content>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OGG服务同步数据</title>
      <link href="/2018/02/10/OGG%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/02/10/OGG%E6%9C%8D%E5%8A%A1%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>想要通过OGG方式实现正式库的修改数据同步到备库中<br><a id="more"></a><br>前提：  </p><ul><li>Oracle 10g</li><li>OGG服务已安装</li><li>两个数据库已有相同用户</li><li>待同步的表已完成主备一致</li></ul><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><p>问题1：连接备库时，报<code>ora-12514 监听程序无法识别连接操作符中请求的服务</code><br>解决：查看<code>$ORACLE_HOME/network/admin</code>目录下没有<code>listener.ora</code>文件，参考其他数据库主机配置，新建了该文件，并写入以下内容，执行<code>lsnrctl status</code>查看监听状态，<code>lsnrctl stop</code>停止监听，<code>lsnrctl start</code>启动监听：</p><pre><code># listener.ora Network Configuration File: /oracle/product/10.2.0/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER =  (SID_LIST =    (SID_DESC =      (SID_NAME = DBSID)      (ORACLE_HOME = ORACLE_HOME)    )  )LISTENER =  (DESCRIPTION_LIST =    (DESCRIPTION =      (ADDRESS = (PROTOCOL = TCP)(HOST = HOST_IP)(PORT = 1521))      (ADDRESS = (PROTOCOL = IPC)(KEY = DBSID))    )  )</code></pre><p>其中：</p><ul><li><code>SID_NAME</code>处，DBSID为Oracle实例iD，可以通过<code>echo $ORACLE_SID</code>来查看，若该环境变量未配置，可以通过<code>ps -ef | grep ora_</code>查看最后一个单词来进行分析</li><li><code>ORACLE_HOME</code>处，ORACLE_HOME应填上具体路径，与<code>echo $ORACLE_HOME</code>相同</li><li><code>HOST</code>处，填写数据库主机IP，如<code>10.131.23.10</code></li><li><code>KEY = DBSID</code>处，DBSID与<code>SID_NAME</code>处填写的一致</li></ul></li><li><p>问题2：报<code>ORA-01034</code>和<code>ORA-27101</code><br>解决：基本就是数据库挂了，需要使用oracle用户登录主机，使用sysdba登录数据库，启动数据库</p><pre><code>sqlplus / as sysdba # 使用sysdba登录数据库startup # 启动数据库</code></pre></li><li><p>问题3：执行./ggsci时报<code>libnnz10.so No such file or directory</code><br>解决：由于环境变量中没有加入<code>$ORACLE_HOME/lib</code>导致</p><pre><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib</code></pre></li><li><p>问题4：启动OGG服务<br>解决：</p><pre><code># 启动cd $GG_HOME./ggscistart mgrstart *# 停止stop *stop mgr</code></pre></li><li><p>问题5：OGG服务启动后，修改正式库表记录，但备库未同步<br>解决：由于replicat服务ABENDED导致不同步，需要修改读检查点和写检查点，尚未完成学习</p></li><li><p>问题6：replicat服务ABENDED<br>解决：通过以下命令找到出问题的点：</p><pre><code>info allinfo REP_group #REP_group为要查询的REPLICAT的GROUP名sh more ggserr.log #查看日志文件</code></pre><p>可以键入v进入vim视图，通过G来到达最后一行查看最近报错信息。</p></li><li><p>问题7：查看REPLICAT进程的参数设置与状态  </p><pre><code>view params REP_group #REP_group为要查询的REPLICAT的GROUP名info REP_group detail #可以查看Error log文件的位置等</code></pre><p>详细可以看参考文章的<a href="http://blog.csdn.net/lqx0405/article/details/44777515" target="_blank" rel="noopener">Oracle GoldenGate学习之–GoldenGate的监控</a></p></li><li><p>问题8：处理ABANDON状态进程</p><pre><code>./ggsciinfo allinfo REP_groupsh ls ./dirrpt -l #查看最近程序执行的日志文件名sh more ./dirrpt/rep_group.dsc #查看最近日志文件内容，一般含有异常记录的描述./logdumpopen ./dirdat/jz000012 #进入logdump查看最近检查点alter replicat rep_group,extseqno 19,extrba 15042355 #修改检查点stop *start *</code></pre></li></ul><p>Tips：若能确认abandon状态中源主机没有任何操作，或许可以直接将检查点修改为<code>info REP_GROUP</code>里展示的检查点，19对应File的后缀，extrba对应RBA：</p><blockquote><p>Log Read Checkpoint  File ./dirdat/jz000019<br>                    2018-03-12 10:22:49.678621  RBA 15042355</p></blockquote><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://blog.csdn.net/u013519551/article/details/53485342" target="_blank" rel="noopener">ORA-01034和ORA-27101的解决方法</a><br><a href="http://blog.sina.com.cn/s/blog_6f7b73770101b6l5.html" target="_blank" rel="noopener">解决 ORA-12514: TNS: 监听程序当前无法识别连接描述符中请求的服务</a><br><a href="http://blog.csdn.net/eviswang/article/details/51034727" target="_blank" rel="noopener">./ggsci: error while loading shared libraries: libnnz11.so: cannot open shared object file: No such</a><br><a href="http://blog.csdn.net/lqx0405/article/details/44777515" target="_blank" rel="noopener">Oracle GoldenGate学习之–GoldenGate的监控</a><br><a href="http://blog.csdn.net/lbyyy/article/details/51775478" target="_blank" rel="noopener">OGG故障排除1例：因B机被修改数据导致replicat服务ABENDED修复</a><br><a href="https://www.cnblogs.com/tan-java/p/5613248.html" target="_blank" rel="noopener">ogg logdump工具使用介绍</a></p>]]></content>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo+github简单命令</title>
      <link href="/2018/02/10/hexo-github%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/02/10/hexo-github%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h3><h4 id="创建文章、标签等"><a href="#创建文章、标签等" class="headerlink" title="创建文章、标签等"></a>创建文章、标签等</h4><ul><li>hexo new “postName” #新建文章</li><li>hexo new page “pageName” #新建页面</li></ul><h4 id="修改文章发布、同步到github等"><a href="#修改文章发布、同步到github等" class="headerlink" title="修改文章发布、同步到github等"></a>修改文章发布、同步到github等</h4><ul><li>hexo p == hexo publish</li><li>hexo g == hexo generate #生成</li><li>hexo s == hexo server #启动服务预览</li><li>hexo d == hexo deploy # 部署到github</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo常用命令笔记</a><br><a href="https://segmentfault.com/q/1010000002561642" target="_blank" rel="noopener">hexo分类与tags配置</a></p>]]></content>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lambda实现switch</title>
      <link href="/2018/02/08/lambda%E5%AE%9E%E7%8E%B0switch/"/>
      <url>/2018/02/08/lambda%E5%AE%9E%E7%8E%B0switch/</url>
      <content type="html"><![CDATA[<p>根据输入的条件符号，对两个输入的数字进行表达式判断<br><a id="more"></a></p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>查了查网上资料，总体有三种方案实现：<br>1、<strong>字典+函数</strong><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcA</span><span class="params">(x)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">...</span><br><span class="line">funcDict&#123;</span><br><span class="line">    <span class="string">'A'</span> : funcA,</span><br><span class="line">    <span class="string">'B'</span> : funcB,</span><br><span class="line">    <span class="string">'C'</span> : funcC</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">funcDict.get(value, funcDefault)(x)</span><br></pre></td></tr></table></figure></p><p>2、<strong>字典+lambda</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lambdaDict&#123;</span><br><span class="line"><span class="code">    'A' : lambda x : x,</span></span><br><span class="line"><span class="code">    'B' : lambda x : x,</span></span><br><span class="line"><span class="code">    'C' : lambda x : x</span></span><br><span class="line">&#125;[<span class="string">value</span>](<span class="link">x</span>)</span><br></pre></td></tr></table></figure></p><p>3、Brian Beck提供了一个类 switch 来实现其他语言中switch的功能</p><p>由于要实现的功能是两个数之间根据输入的表达式来进行比较，所以选择了写起来比较简洁（自认为简洁）的lambda<br><strong>样例</strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def opJudge(processCnt, op, expectCnt):</span><br><span class="line">    judgeAns = &#123;</span><br><span class="line">        <span class="string">'='</span> : <span class="type">lambda</span> x, y : <span class="type">x</span> == y,</span><br><span class="line">        <span class="string">'&gt;'</span> : <span class="type">lambda</span> x, y : <span class="type">x</span> &gt; y,</span><br><span class="line">        <span class="string">'&lt;'</span> : <span class="type">lambda</span> x, y : <span class="type">x</span> &lt; y,</span><br><span class="line">        '&gt;=' : <span class="type">lambda</span> x, y : <span class="type">x</span> &gt;= y,</span><br><span class="line">        '&lt;=' : <span class="type">lambda</span> x, y : <span class="type">x</span> &lt;= y,</span><br><span class="line">        '!=' : <span class="type">lambda</span> x, y : <span class="type">x</span> != y,</span><br><span class="line">    &#125;[op](processCnt, expectCnt)</span><br><span class="line">    <span class="keyword">return</span> judgeAns</span><br></pre></td></tr></table></figure></p><p><small>写的时候对lambda的认识：lambda后面紧跟的是<strong>形参</strong>，就是func(x, y)里面的x、y，冒号后面的是<strong>方法</strong>，就是func(…){method}里面的method</small></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/suiyunonghen/article/details/3734135" target="_blank" rel="noopener">Python中Swithch Case语法实现</a><br><a href="http://blog.csdn.net/mathboylinlin/article/details/9413551" target="_blank" rel="noopener">Python学习笔记（十二）：lambda表达式与函数式编程</a></p>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FirstBlog</title>
      <link href="/2018/02/08/FirstBlog/"/>
      <url>/2018/02/08/FirstBlog/</url>
      <content type="html"><![CDATA[<p>第一次使用<code>hexo</code>+<code>GitHub</code>的方式搭建个人博客，如果不搞各种插件的话，搭起来还是比较简单的，不过…确定<del>有定力</del>不去尝试各种插件么？<br><a id="more"></a></p><p>流程大概就是：</p><ol><li>观望<code>GitHub</code>对<code>hexo</code>与<code>jekyll</code>的支持程度，最终选择了自己曾经<strong>见过</strong>的<code>hexo</code></li><li>在<code>Github</code>上建立个人博客repository。这部分比较<del>简单</del>，主要纠结在了不断的404上。</li><li>主机上原来各种捣鼓都装上了Node.js、git这一堆东西</li><li><code>hexo init</code>开始装上了hexo，摸索了一下hexo结构</li><li>大概最纠结的事情出现了：找主题。前后试过<code>landscape</code>、<code>next</code>、<code>maupassant</code>、<code>light</code>，最喜欢的样式是<code>light</code>，在用的是<code>maupassant</code>。感觉<code>next</code>动画很足，缺点也是动画导致整体渲染看起来比较慢；<code>light</code>的样式看起来舒服，不足是提供的功能真的有点儿少……</li><li>花了一顿晚饭钱买了个域名，在考虑要不要注一个<code>.com</code>的。</li><li><a href="https://tongji.baidu.com/open/" target="_blank" rel="noopener">百度统计</a>、<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a>、七牛、又拍等</li></ol><p>下一步计划？或者说是期望：  </p><ul><li>增加评论功能（现在没有，找我的话通过Github吧~）</li><li>租个云服务器做自己的后台服务</li><li>动手写一个前后端交互的页面</li><li>考虑如何将内容同步到简书或者segmentfault</li></ul><p>END……</p>]]></content>
      
      <categories>
          
          <category> Whisper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
